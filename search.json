{
  "entries": [
    
      
        
        {
          "title": "Atom Selections",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/atom-selections/",
          "body": " Atom Selections Text selections in Atom support a number of actions, such as scoping deletion, indentation and search actions, and marking text for actions such as quoting and bracketing. Selections mirror many of the movement commands. They're actually exactly the same keybindings as the movement commands, but with a Shift key added in.   Shift+Up or Ctrl+Shift+P - Select up  Shift+Down or Ctrl+Shift+N - Select down  Shift+Left or Ctrl+Shift+B - Select previous character  Shift+Right or Ctrl+Shift+F - Select next character  Alt+Shift+LeftCtrl+Shift+Left or Alt+Shift+B - Select to beginning of word  Alt+Shift+RightCtrl+Shift+Right or Alt+Shift+F - Select to end of word  Cmd+Shift+RightShift+End or Ctrl+Shift+E - Select to end of line  Cmd+Shift+LeftShift+Home or Ctrl+Shift+A - Select to first character of line  Cmd+Shift+UpCtrl+Shift+Home - Select to top of file  Cmd+Shift+DownCtrl+Shift+End - Select to bottom of file  In addition to the cursor movement selection commands, there are also a few commands that help with selecting specific areas of content.   Cmd+ACtrl+A - Select the entire contents of the file  Cmd+LCtrl+L - Select the entire line     Ctrl+Shift+W - Select the current word  ",
          "excerpt": " Atom Selections Text selections in Atom support a number of actions, such as scoping deletion, indentation and search actions, and marking t…"
        },
      
    
      
        
        {
          "title": "Folding",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/folding/",
          "body": " Folding If you want to see an overview of the structure of the code file you're working on, folding can be a helpful tool. Folding hides blocks of code such as functions or looping blocks in order to simplify what is on your screen. You can fold blocks of code by clicking the arrows that appear when you hover your mouse cursor over the gutter. You can also fold and unfold from the keyboard with the Alt+Cmd+[Alt+Ctrl+[ and Alt+Cmd+]Alt+Ctrl+] keybindings.  To fold everything, use Alt+Cmd+Shift+[Alt+Ctrl+Shift+[ and to unfold everything use Alt+Cmd+Shift+]Alt+Ctrl+Shift+]. You can also fold at a specific indentation level with Cmd+KCtrl+K Cmd+0-9Ctrl+0-9 where the number is the indentation depth. Finally, you can fold arbitrary sections of your code or text by making a selection and then typing Alt+Cmd+Ctrl+FAlt+Ctrl+F or choosing \"Fold Selection\" in the Command Palette.",
          "excerpt": " Folding If you want to see an overview of the structure of the code file you're working on, folding can be a helpful tool. Folding hides blo…"
        },
      
    
      
        
        {
          "title": "GitHub package",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/github-package/",
          "body": " GitHub package The github package brings Git and GitHub integration right inside Atom.  Initialize Clone Branch Stage Discard Commit Amend Push Pull Resolve conflicts View Pull Requests  Most of the functionality lives in the Git and GitHub panel. There are different ways to access them, probably the most common way is through their keybindings:  Open the Git panel: Ctrl+9  Open the GitHub panel: Ctrl+8   Or you can also toggle the Git panel from the Status Bar by clicking on the changed files icon:    Initialize repositories In case a project doesn't have a Git repository yet, you can create one from the Git panel.   Clone repositories To clone a repository, run the GitHub: Clone command. In the dialog paste a URL of a repository and click \"Clone\". A new project will get added to the Tree View.   Branch To open the branch tooltip, click the branch icon in the Status Bar. From there you can to create or switch branches.   Stage After making some changes, stage anything you want to be part of the next commit. Choose between staging...   All changes: Click the \"Stage All\" button in the \"Unstaged Changes\" bar.  Files: Double-click a file or select a file and press Enter.  Hunk: Click on the \"Stage Hunk\" button or select a hunk and press Enter.  Lines: Click on a line (or drag on multiple lines) to select, then click on the \"Stage Selection\" button. Or use the / key to toggle from hunk mode to line mode, then press Enter to stage just a single line.  Use the Left or Right arrow key to switch between file list and the diff view. Unstaging can be done in the same way.   Discard changes If you no longer want to keep some changes, you can discard them. It's similar to staging, but accessible behind a context menu.   All changes: Right-click the \"Unstaged Changes\" bar and choose \"Discard All Changes\".  Files: Right-click a file (or multiple) and choose \"Discard Changes\".  Hunk: Click on the trash icon in the top bar of a hunk.  Lines: Right-click on a line (or multiple) and choose \"Discard Selection\".    Commit Once you've staged your changes, enter a commit message. Feel free to describe the commit in more detail after leaving an empty line. Finalize by clicking the Commit button.  If you need more space, click the expand icon at the bottom right. It will open a commit editor in the center.  Amend previous commit In case you forgot to commit a change and would like to add it to your previous commit, clicking the \"Amend\" checkbox. Now you can stage more changes or adjust the commit message.   Push When you're ready to share your changes with your team members, click the Push button in the Status Bar tooltip. If your local branch doesn't exist on the remote repository, Atom will offer to create a remote branch for you.   Pull Click on the Fetch button to see if anyone made changes. Pull to get the changes into your local branch.   Resolve conflicts Sometimes there can be conflicts when trying to merge. Files that have merge conflicts will show up in the \"Merge Conflicts\" list. Click on a file to open the editor. There you can resolve the conflict by picking a version or make further edits. Once done, stage the file and commit.   View Pull Requests If there is a Pull Request for your current branch, you can see its status in the \"GitHub\" panel. Click on Conversation to see the timeline. ",
          "excerpt": " GitHub package The github package brings Git and GitHub integration right inside Atom.  Initialize Clone Branch Stage Discard Commit Amend P…"
        },
      
    
      
        
        {
          "title": "Autocomplete",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/autocomplete/",
          "body": " Autocomplete If you're still looking to save some typing time, Atom also ships with simple autocompletion functionality. The autocomplete system lets you view and insert possible completions in the editor using Tab or Enter.  By default, the autocomplete system will look through the current open file for strings that match what you're starting to type. If you want more options, in the Settings panel for the autocomplete-plus package you can toggle a setting to make autocomplete-plus look for text in all your open buffers rather than just the current file. The Autocomplete functionality is implemented in the autocomplete-plus package.",
          "excerpt": " Autocomplete If you're still looking to save some typing time, Atom also ships with simple autocompletion functionality. The autocomplete sy…"
        },
      
    
      
        
        {
          "title": "Editing and Deleting Text",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/editing-and-deleting-text/",
          "body": " Editing and Deleting Text So far we've looked at a number of ways to move around and select regions of a file, so now let's actually change some of that text. Obviously you can type in order to insert characters, but there are also a number of ways to delete and manipulate text that could come in handy.  Basic Manipulation There are a handful of cool keybindings for basic text manipulation that might come in handy. These range from moving around lines of text and duplicating lines to changing the case.   Cmd+JCtrl+J - Join the next line to the end of the current line  Cmd+Ctrl+Up/DownCtrl+Up/Down - Move the current line up or down  Cmd+Shift+DCtrl+Shift+D - Duplicate the current line  Cmd+K Cmd+UCtrl+K Ctrl+U - Upper case the current word  Cmd+K Cmd+LCtrl+K Ctrl+L - Lower case the current word     Ctrl+T - Transpose characters. This swaps the two characters on either side of the cursor.   Atom also has built in functionality to re-flow a paragraph to hard-wrap at a given maximum line length. You can format the current selection to have lines no longer than 80 (or whatever number editor.preferredLineLength is set to) characters using Alt+Cmd+QAlt+Ctrl+Q. If nothing is selected, the current paragraph will be reflowed.  Deleting and Cutting You can also delete or cut text out of your buffer with some shortcuts. Be ruthless.   Ctrl+Shift+K - Delete current line  Alt+Backspace or Alt+HCtrl+Backspace - Delete to beginning of word  Alt+Delete or Alt+DCtrl+Delete - Delete to end of word     Cmd+Delete - Delete to end of line  Ctrl+K - Cut to end of line  Cmd+Backspace - Delete to beginning of line    Multiple Cursors and Selections One of the cool things that Atom can do out of the box is support multiple cursors. This can be incredibly helpful in manipulating long lists of text.   Cmd+ClickCtrl+Click - Add a new cursor at the clicked location  Ctrl+Shift+Up/DownAlt+Ctrl+Up/DownAlt+Shift+Up/Down - Add another cursor above/below the current cursor  Cmd+DCtrl+D - Select the next word in the document that is the same as the currently selected word  Cmd+Ctrl+GAlt+F3 - Select all words in the document that are the same as the currently selected word     Cmd+Shift+L - Convert a multi-line selection into multiple cursors   Using these commands you can place cursors in multiple places in your document and effectively execute the same commands in multiple places at once.  This can be incredibly helpful in doing many type of repetitive tasks such as renaming variables or changing the format of some text. You can use this with almost any plugin or command - for example, changing case and moving or duplicating lines. You can also use the mouse to select text with the CmdCtrl key pressed down to select multiple regions of your text simultaneously.  Whitespace Atom comes with several commands to help you manage the whitespace in your document. One very useful pair of commands converts leading spaces into tabs and converts leading tabs into spaces. If you're working with a document that has mixed whitespace, these commands are great for helping to normalize the file. There are no keybindings for the whitespace commands, so you will have to search your command palette for \"Convert Spaces to Tabs\" (or vice versa) to run one of these commands. The whitespace commands are implemented in the atom/whitespace package. The settings for the whitespace commands are managed on the page for the whitespace package.   The \"Remove Trailing Whitespace\" option is on by default. This means that every time you save any file opened in Atom, it will strip all trailing whitespace from the file. If you want to disable this, go to the whitespace package in your settings panel and uncheck that option.  Atom will also by default ensure that your file has a trailing newline. You can also disable this option on that screen.  Brackets Atom ships with intelligent and easy to use bracket handling. It will by default highlight [], (), and {} style brackets when your cursor is over them. It will also highlight matching XML and HTML tags. Atom will also automatically autocomplete [], (), and {}, \"\", '', “”, ‘’, «», ‹›, and backticks when you type the leading one. If you have a selection and you type any of these opening brackets or quotes, Atom will enclose the selection with the opening and closing brackets or quotes. There are a few other interesting bracket related commands that you can use.   Ctrl+M - Jump to the bracket matching the one adjacent to the cursor. It jumps to the nearest enclosing bracket when there's no adjacent bracket.  Cmd+Ctrl+MAlt+Ctrl+, - Select all the text inside the current brackets  Alt+Cmd+.Alt+Ctrl+. - Close the current XML/HTML tag  The brackets functionality is implemented in the bracket-matcher package. Like all of these packages, to change defaults related to bracket handling, or to disable it entirely, you can navigate to this package in the Settings view.  Encoding Atom also ships with some basic file encoding support should you find yourself working with non-UTF-8 encoded files, or should you wish to create one.   Ctrl+Shift+UAlt+U - Toggle menu to change file encoding  If you pull up the file encoding dialog, you can choose an alternate file encoding to save your file in. When you open a file, Atom will try to auto-detect the encoding. If Atom can't identify the encoding, the encoding will default to UTF-8, which is also the default encoding for new files.  If you pull up the encoding menu and change the active encoding to something else, the file will be written out in that encoding the next time you save the file. The encoding selector is implemented in the encoding-selector package.",
          "excerpt": " Editing and Deleting Text So far we've looked at a number of ways to move around and select regions of a file, so now let's actually change …"
        },
      
    
      
        
        {
          "title": "Snippets",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/snippets/",
          "body": " Snippets Snippets are an incredibly powerful way to quickly generate commonly needed code syntax from a shortcut. The idea is that you can type something like habtm and then press the Tab key and it will expand into has_and_belongs_to_many. Many Core and Community packages come bundled with their own snippets that are specific to it. For example, the language-html package that provides support for HTML syntax highlighting and grammar comes with dozens of snippets to create many of the various HTML tags you might want to use. If you create a new HTML file in Atom, you can type html and then press Tab and it will expand to: &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;  It will also position the cursor in the middle of the title tag so you can immediately start filling out the tag. Many snippets have multiple focus points that you can move through with the Tab key as well - for instance, in the case of this HTML snippet, once you've filled out the title tag you can press Tab and the cursor will move to the middle of the body tag. To see all the available snippets for the file type that you currently have open, choose \"Snippets: Available\" in the Command Palette.  You can also use fuzzy search to filter this list down by typing in the selection box. Selecting one of them will execute the snippet where your cursor is (or multiple cursors are).  Creating Your Own Snippets So that's pretty cool, but what if there is something the language package didn't include or something that is custom to the code you write? Luckily it's incredibly easy to add your own snippets. There is a text file in your ~/.atom%USERPROFILE%\\.atom directory called snippets.cson that contains all your custom snippets that are loaded when you launch Atom. You can also easily open up that file by selecting the Atom &gt; SnippetsEdit &gt; SnippetsFile &gt; Snippets menu.  Snippet Format So let's look at how to write a snippet. The basic snippet format looks like this: '.source.js': 'console.log': 'prefix': 'log' 'body': 'console.log(${1:\"crash\"});$2'  The leftmost keys are the selectors where these snippets should be active. The easiest way to determine what this should be is to go to the language package of the language you want to add a snippet for and look for the \"Scope\" string. For example, if we wanted to add a snippet that would work for Java files, we would look up the language-java package in our Settings view and we can see the Scope is source.java. Then the top level snippet key would be that prepended by a period (like a CSS class selector would do).  The next level of keys are the snippet names. These are used for describing the snippet in a more readable way in the snippet menu. You can name them whatever you want. Under each snippet name is a prefix that should trigger the snippet and a body to insert when the snippet is triggered. Each $ followed by a number is a tab stop. Tab stops are cycled through by pressing Tab once a snippet has been triggered. Tab stops with the same number will create multiple cursors. The above example adds a log snippet to JavaScript files that would expand to: console.log(\"crash\");  The string \"crash\" would be initially selected and pressing tab again would place the cursor after the ;  Snippet keys, unlike CSS selectors, can only be repeated once per level. If there are duplicate keys at the same level, then only the last one will be read. See Configuring with CSON for more information.   Multi-line Snippet Body You can also use CoffeeScript multi-line syntax using \"\"\" for larger templates: '.source.js': 'if, else if, else': 'prefix': 'ieie' 'body': \"\"\" if (${1:true}) { $2 } else if (${3:false}) { $4 } else { $5 } \"\"\"  As you might expect, there is a snippet to create snippets. If you open up a snippets file and type snip and then press Tab, you will get the following text inserted: '.source.js': 'Snippet Name': 'prefix': 'hello' 'body': 'Hello World!'   just fill that bad boy out and you have yourself a snippet. As soon as you save the file, Atom should reload the snippets and you will immediately be able to try it out.  Multiple Snippets per Source You can see below the format for including multiple snippets for the same scope in your snippets.cson file. Just include the snippet name, prefix, and body keys for additional snippets inside the scope key: '.source.gfm': 'Hello World': 'prefix': 'hewo' 'body': 'Hello World!' 'Github Hello': 'prefix': 'gihe' 'body': 'Octocat says Hi!' 'Octocat Image Link': 'prefix': 'octopic' 'body': '![GitHub Octocat](https://assets-cdn.github.com/images/modules/logos_page/Octocat.png)'  Again, see Configuring with CSON for more information on CSON key structure and non-repeatability.  More Info The snippets functionality is implemented in the snippets package. For more examples, see the snippets in the language-html and language-javascript packages.",
          "excerpt": " Snippets Snippets are an incredibly powerful way to quickly generate commonly needed code syntax from a shortcut. The idea is that you can t…"
        },
      
    
      
        
        {
          "title": "Atom Packages",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/atom-packages/",
          "body": " Atom Packages First we'll start with the Atom package system. As we mentioned previously, Atom itself is a very basic core of functionality that ships with a number of useful packages that add new features like the Tree View and the Settings View. In fact, there are more than 90 packages that comprise all of the functionality that is available in Atom by default. For example, the Welcome screen that you see when you first start Atom, the spell checker, the themes and the Fuzzy Finder are all packages that are separately maintained and all use the same APIs that you have access to, as we'll see in great detail in Hacking Atom. This means that packages can be incredibly powerful and can change everything from the very look and feel of the entire interface to the basic operation of even core functionality. In order to install a new package, you can use the Install tab in the now familiar Settings View. Open up the Settings View using Cmd+,Ctrl+,, click on the \"Install\" tab and type your search query into the box under Install Packages. The packages listed here have been published to https://atom.io/packages which is the official registry for Atom packages. Searching on the Settings View will go to the Atom package registry and pull in anything that matches your search terms.  All of the packages will come up with an \"Install\" button. Clicking that will download the package and install it. Your editor will now have the functionality that the package provides.  Package Settings Once a package is installed in Atom, it will show up in the Settings View under the \"Packages\" tab, along with all the preinstalled packages that come with Atom. To filter the list in order to find one, you can type into search box directly under the \"Installed Packages\" heading.  Clicking on the \"Settings\" button for a package will give you the settings screen for that package specifically. Here you have the option of changing some of the default variables for the package, seeing what all the command keybindings are, disabling the package temporarily, looking at the source code, seeing the current version of the package, reporting issues and uninstalling the package. If a new version of any of your packages is released, Atom will automatically detect it and you can upgrade the package from either this screen or from the \"Updates\" tab. This helps you easily keep all your installed packages up to date.  Atom Themes You can also find and install new themes for Atom from the Settings View. These can be either UI themes or syntax themes and you can search for them from the \"Install\" tab, just like searching for new packages. Make sure to press the \"Themes\" toggle next to the search box.  Clicking on the theme title will take you to a profile page for the theme on atom.io, which often has a screenshot of the theme. This way you can see what it looks like before installing it. Clicking on \"Install\" will install the theme and make it available in the Theme dropdowns as we saw in Changing the Theme.   Command Line You can also install packages or themes from the command line using apm.  Check that you have apm installed by running the following command in your terminal:  apm help install  You should see a message print out with details about the apm install command. If you do not, see the Installing Atom section for instructions on how to install the atom and apm commands for your system.  You can also install packages by using the apm install command:   apm install &lt;package_name&gt; to install the latest version.  apm install &lt;package_name&gt;@&lt;package_version&gt; to install a specific version.  For example apm install emmet@0.1.5 installs the 0.1.5 release of the Emmet package. You can also use apm to find new packages to install. If you run apm search, you can search the package registry for a search term.  apm search coffee Search Results For 'coffee' (29) ├── build-coffee Atom Build provider for coffee, compiles CoffeeScript (1160 downloads, 2 stars) ├── scallahan-coffee-syntax A coffee inspired theme from the guys over at S.CALLAHAN (183 downloads, 0 stars) ├── coffee-paste Copy/Paste As : Js ➤ Coffee / Coffee ➤ Js (902 downloads, 4 stars) ├── atom-coffee-repl Coffee REPL for Atom Editor (894 downloads, 2 stars) ├── coffee-navigator Code navigation panel for Coffee Script (3493 downloads, 22 stars) ... ├── language-iced-coffeescript Iced coffeescript for atom (202 downloads, 1 star) └── slontech-syntax Dark theme for web developers ( HTML, CSS/LESS, PHP, MYSQL, javascript, AJAX, coffee, JSON ) (2018 downloads, 3 stars)  You can use apm view to see more information about a specific package.  apm view build-coffee build-coffee ├── 0.6.4 ├── https://github.com/idleberg/atom-build-coffee ├── Atom Build provider for coffee, compiles CoffeeScript ├── 1152 downloads └── 2 stars &gt; Run `apm install build-coffee` to install this package. ",
          "excerpt": " Atom Packages First we'll start with the Atom package system. As we mentioned previously, Atom itself is a very basic core of functionality …"
        },
      
    
      
        
        {
          "title": "Basic Customization",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/basic-customization/",
          "body": " Basic Customization Now that we are feeling comfortable with just about everything built into Atom, let's look at how to tweak it. Perhaps there is a keybinding that you use a lot but feels wrong or a color that isn't quite right for you. Atom is amazingly flexible, so let's go over some of the simpler flexes it can do.  Configuring with CSON All of Atom's config files (with the exception of your style sheet and your Init Script) are written in CSON, short for CoffeeScript Object Notation. Just like its namesake JSON, JavaScript Object Notation, CSON is a text format for storing structured data in the form of simple objects made up of key-value pairs. key: key: value key: value key: [value, value]  Objects are the backbone of any CSON file, and are delineated by indentation (as in the above example). A key's value can either be a String, a Number, an Object, a Boolean, null, or an Array of any of these data types.  Just like the more common JSON, CSON's keys can only be repeated once per object. If there are duplicate keys, then the last usage of that key overwrites all others, as if they weren't there. The same holds true for Atom's config files. Don't do this: # Only the second snippet will be loaded '.source.js': 'console.log': 'prefix': 'log' 'body': 'console.log(${1:\"crash\"});$2' '.source.js': 'console.error': 'prefix': 'error' 'body': 'console.error(${1:\"crash\"});$2'  Use this instead: # Both snippets will be loaded '.source.js': 'console.log': 'prefix': 'log' 'body': 'console.log(${1:\"crash\"});$2' 'console.error': 'prefix': 'error' 'body': 'console.error(${1:\"crash\"});$2'    Style Tweaks If you want to apply quick-and-dirty personal styling changes without creating an entire theme that you intend to publish, you can add styles to the styles.less file in your ~/.atom%USERPROFILE%\\.atom directory. You can open this file in an editor from the Atom &gt; StylesheetFile &gt; StylesheetEdit &gt; Stylesheet menu.    For example, to change the colors of the Status Bar, you could add the following rule to your styles.less file: .status-bar { color: white; background-color: black; }  The easiest way to see what classes are available to style is to inspect the DOM manually via the Developer Tools. We'll go over the Developer Tools in great detail in the next chapter, but for now let's take a simple look. You can open the Developer Tools by pressing Alt+Cmd+ICtrl+Shift+I, which will bring up the Chromium Developer Tools panel.  With the Developer Tools, you can inspect all the elements in Atom. If you want to update the style of something, you can figure out what classes it has and add a Less rule to your stylesheet to modify it.  If you are unfamiliar with Less, it is a basic CSS preprocessor that makes some things in CSS a bit easier. You can learn more about it at lesscss.org. If you prefer to use CSS instead, you can do that in the same styles.less file, since CSS is also valid in Less.   Customizing Keybindings Atom keymaps work similarly to stylesheets. Just as stylesheets use selectors to apply styles to elements, Atom keymaps use selectors to associate key combinations with events in specific contexts. Here's a small example, excerpted from Atom's built-in keymap: 'atom-text-editor': 'enter': 'editor:newline' 'atom-text-editor[mini] input': 'enter': 'core:confirm'  This keymap defines the meaning of Enter in two different contexts. In a normal editor, pressing Enter triggers the editor:newline command, which causes the editor to insert a newline. But if the same keystroke occurs inside a select list's mini-editor, it instead triggers the core:confirm command based on the binding in the more-specific selector. By default, keymap.cson is loaded when Atom is started. It will always be loaded last, giving you the chance to override bindings that are defined by Atom's core keymaps or third-party packages. You can open this file in an editor from the Atom &gt; KeymapFile &gt; KeymapEdit &gt; Keymap menu. You can see all the keybindings that are currently configured in your installation of Atom in the Keybindings tab in the Settings View. If you run into problems with keybindings, the Keybinding Resolver is a huge help. It can be opened with the Cmd+.Ctrl+. key combination. It will show you what keys Atom saw you press and what command Atom executed because of that combination.  Global Configuration Settings Atom loads configuration settings from the config.cson file in your ~/.atom%USERPROFILE%\\.atom directory. '*': 'core': 'excludeVcsIgnoredPaths': true 'editor': 'fontSize': 18  The configuration is grouped into global settings under the * key and language-specific settings under scope named keys like .python.source or .html.text. Underneath that, you'll find configuration settings grouped by package name or one of the two core namespaces: core or editor. You can open this file in an editor from the Atom &gt; ConfigFile &gt; ConfigEdit &gt; Config menu.  Configuration Key Reference   core   customFileTypes: Associations of language scope to file extensions (see Customizing Language Recognition)  disabledPackages: An array of package names to disable  excludeVcsIgnoredPaths: Don't search within files specified by .gitignore   ignoredNames: File names to ignore across all of Atom  projectHome: The directory where projects are assumed to be located  themes: An array of theme names to load, in cascading order    editor   autoIndent: Enable/disable basic auto-indent (defaults to true)  nonWordCharacters: A string of non-word characters to define word boundaries  fontSize: The editor font size  fontFamily: The editor font family  invisibles: A hash of characters Atom will use to render whitespace characters. Keys are whitespace character types, values are rendered characters (use value false to turn off individual whitespace character types)   tab: Hard tab characters  cr: Carriage return (for Microsoft-style line endings)  eol: \\n characters  space: Leading and trailing space characters    lineHeight: Height of editor lines, as a multiplier of font size  preferredLineLength: Identifies the length of a line (defaults to 80)  showInvisibles: Whether to render placeholders for invisible characters (defaults to false)  showIndentGuide: Show/hide indent indicators within the editor  showLineNumbers: Show/hide line numbers within the gutter  softWrap: Enable/disable soft wrapping of text within the editor  softWrapAtPreferredLineLength: Enable/disable soft line wrapping at preferredLineLength   tabLength: Number of spaces within a tab (defaults to 2)    fuzzyFinder   ignoredNames: Files to ignore only in the fuzzy-finder    whitespace   ensureSingleTrailingNewline: Whether to reduce multiple newlines to one at the end of files  removeTrailingWhitespace: Enable/disable stripping of whitespace at the end of lines (defaults to true)    wrap-guide   columns: Array of hashes with a pattern and column key to match the path of the current editor to a column position.     Language Specific Configuration Settings You can also set several configuration settings differently for different file types. For example, you may want Atom to soft wrap markdown files, have two-space tabs for ruby files, and four-space tabs for python files. There are several settings now scoped to an editor's language. Here is the current list: editor.autoIndent editor.autoIndentOnPaste editor.invisibles editor.nonWordCharacters editor.preferredLineLength editor.scrollPastEnd editor.showIndentGuide editor.showInvisibles editor.softWrap editor.softWrapAtPreferredLineLength editor.softWrapHangingIndent editor.tabLength   Language-specific Settings in the Settings View You can edit these config settings in the Settings View on a per-language basis. Click on \"Packages\" tab in the navigation bar on the left, search for the language of your choice, select it, and edit away!   Language-specific Settings in your Config File You can also edit the config.cson directly. To open your configuration file via the Command Palette, press Cmd+Shift+PCtrl+Shift+P type open config, and press Enter. Global settings are under the * key, and each language can have its own top-level key. This key is the language's scope. Language-specific settings take precedence over anything set in the global section for that language only. '*': # all languages unless overridden 'editor': 'softWrap': false 'tabLength': 8 '.source.gfm': # markdown overrides 'editor': 'softWrap': true '.source.ruby': # ruby overrides 'editor': 'tabLength': 2 '.source.python': # python overrides 'editor': 'tabLength': 4   Finding a Language's Scope Name In order to write these overrides effectively, you'll need to know the scope name for the language. We've already done this for finding a scope for writing a snippet in Snippet Format, but we can quickly cover it again. The scope name is shown in the settings view for each language. Click on \"Packages\" in the navigation on the left, search for the language of your choice, select it, and you should see the scope name under the language name heading:  Another way to find the scope for a specific language is to open a file of its kind and press Alt+Cmd+PAlt+Ctrl+Shift+P to show all scopes for the current position of the cursor. The scope mentioned top most is always the language for this kind of file, the scopes following are specific to the cursor position:  These scopes can be especially useful to style the editor, since they can also be used as class names in your stylesheet.  Customizing Language Recognition If you want Atom to always recognize certain file types as a specific grammar, you'll need to manually edit your config.cson file. You can open it using the Application: Open Your Config command from the Command Palette. For example, if you wanted to add the foo extension to the CoffeeScript language, you could add this to your configuration file under the *.core section: '*': core: customFileTypes: 'source.coffee': [ 'foo' ]  In the example above, source.coffee is the language's scope name (see Finding a Language's Scope Name for more information) and foo is the file extension to match without the period. Adding a period to the beginning of either of these will not work.  Controlling Where Customization is Stored to Simplify Your Workflow The CSON configuration files for Atom are stored on disk on your machine. The location for this storage is customizable. The default is to use the home directory of the user executing the application. The Atom Home directory will, by default, be called .atom and will be located in the root of the home directory of the user.  Custom home location with an environment variable An environment variable can be used, though to make Atom use a different location. This can be useful for several reasons. One of these may be that multiple user accounts on a machine want to use the same Atom Home. The environment variable used to specify and alternate location is called ATOM_HOME. If this environment variable exists, the location specified will be used to load and store Atom settings.  Taking your customization with you with Portable Mode In addition to using the ATOM_HOME environment variable, Atom can also be set to use \"Portable Mode\". Portable Mode is most useful for taking Atom with you, with all your custom setting and packages, from machine to machine. This may take the form of keeping Atom on a USB drive or a cloud storage platform that syncs folders to different machines, like Dropbox. Atom is in Portable Mode when there is a directory named .atom sibling to the directory in which the atom executable file lives. For example, the installed Atom directory can be placed into a Dropbox folder next to a .atom folder.  With such a setup, Atom will use the same Home directory with the same settings for any machine with this directory syncronized/plugged in.  Moving to Portable Mode Atom provides a command-line parameter option for setting Portable Mode.  atom --portable  Executing atom with the --portable option will take the .atom directory you have in the default location (~/.atom) and copy the relevant contents for your configuration to a new home directory in the Portable Mode location. This enables easily moving from the default location to a portable operation without losing the customization you have already set up.",
          "excerpt": " Basic Customization Now that we are feeling comfortable with just about everything built into Atom, let's look at how to tweak it. Perhaps t…"
        },
      
    
      
        
        {
          "title": "Pending Pane Items",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/pending-pane-items/",
          "body": " Pending Pane Items \"Pending Pane Items\" were formerly referred to as \"Preview Tabs\" When you open a new file by single-clicking in the Tree View, it will open in a new tab with an italic title. This indicates that the file is \"pending\". When a file is pending, it will be replaced by the next pending file that is opened. This allows you to click through a bunch of files to find something without having to go back and close them all. You can confirm a pending file by doing any of the following:  Double-clicking the tab of the file Double-clicking the file in the tree view Editing the contents of the file Saving the file  You can also open a file already confirmed by double-clicking it in the tree view instead of single-clicking it.  Disabling Pending Pane Items  If you would prefer to not have files open in pending form, you can disable this behavior by unchecking \"Allow Pending Pane Items\" in the Core Settings section of the Settings View. With pending pane items disabled, single-clicking a file in the Tree View will select the file but not open it. You will have to double-click the file to open it.",
          "excerpt": " Pending Pane Items \"Pending Pane Items\" were formerly referred to as \"Preview Tabs\" When you open a new file by single-clicking in the T…"
        },
      
    
      
        
        {
          "title": "Version Control in Atom",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/version-control-in-atom/",
          "body": " Version Control in Atom Version control is an important aspect of any project and Atom comes with basic Git and GitHub integration built in. In order to use version control in Atom, the project root needs to contain the Git repository.  Checkout HEAD revision The Alt+Cmd+ZAlt+Ctrl+Z keybinding checks out the HEAD revision of the file in the editor. This is a quick way to discard any saved and staged changes you've made and restore the file to the version in the HEAD commit. This is essentially the same as running git checkout HEAD -- &lt;path&gt; and git reset HEAD -- &lt;path&gt; from the command line for that path.  This command goes onto the undo stack so you can use Cmd+ZCtrl+Z afterwards to restore the previous contents.  Git status list Atom ships with the fuzzy-finder package which provides Cmd+TCtrl+T to quickly open files in the project and Cmd+BCtrl+B to jump to any open editor. The package also provides Cmd+Shift+BCtrl+Shift+B which displays a list of all the untracked and modified files in the project. These will be the same files that you would see on the command line if you ran git status.  An icon will appear to the right of each file letting you know whether it is untracked or modified.  Commit editor Atom can be used as your Git commit editor and ships with the language-git package which adds syntax highlighting to edited commit, merge, and rebase messages.  You can configure Atom to be your Git commit editor with the following command:  git config --global core.editor \"atom --wait\"  The language-git package will help remind you to be brief by colorizing the first lines of commit messages when they're longer than 50 or 65 characters.  Status bar icons The status-bar package that ships with Atom includes several Git decorations that display on the right side of the status bar:  The currently checked out branch name is shown with the number of commits the branch is ahead of or behind its upstream branch. An icon is added if the file is untracked, modified, or ignored. The number of lines added and removed since the file was last committed will be displayed as well.  Line diffs The included git-diff package colorizes the gutter next to lines that have been added, edited, or removed.  This package also adds Alt+G Down and Alt+G Up keybindings that allow you to move the cursor to the next or previous diff in the current editor.  Open on GitHub If the project you're working on is on GitHub, there are also some very useful integrations you can use. Most of the commands will take the current file you're viewing and open a view of that file on GitHub - for instance, the blame or commit history of that file.   Alt+G O - Open file on GitHub  Alt+G B - Open Blame view of file on GitHub  Alt+G H - Open History view of file on GitHub  Alt+G C - Copy the URL of the current file on GitHub to the clipboard  Alt+G R - Branch compare on GitHub  The branch comparison shows you the commits that are on the branch you're currently working on locally that are not on the mainline branch. ",
          "excerpt": " Version Control in Atom Version control is an important aspect of any project and Atom comes with basic Git and GitHub integration built in.…"
        },
      
    
      
        
        {
          "title": "Find and Replace",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/find-and-replace/",
          "body": " Find and Replace Finding and replacing text in your file or project is quick and easy in Atom.   Cmd+FCtrl+F - Search within a buffer  Cmd+Shift+FCtrl+Shift+F - Search the entire project  If you launch either of those commands, you'll be greeted with the Find and Replace panel at the bottom of your screen.  To search within your current file you can press Cmd+FCtrl+F, type in a search string and press Enter (or Cmd+GF3 or the \"Find Next\" button) multiple times to cycle through all the matches in that file. The Find and Replace panel also contains buttons for toggling case sensitivity, performing regular expression matching and scoping the search to selections.  If you type a string in the replacement text box, you can replace matches with a different string. For example, if you wanted to replace every instance of the string \"Scott\" with the string \"Dragon\", you would enter those values in the two text boxes and press the \"Replace All\" button to perform the replacements.  Note: With a regular expression search, the replacement syntax to refer back to search groups is $1, $2, … $&amp;   You can also find and replace throughout your entire project if you invoke the panel with Cmd+Shift+FCtrl+Shift+F.  This is a great way to find out where in your project a function is called, an anchor is linked to or a specific misspelling is located. Click on the matching line to jump to that location in that file. You can limit a search to a subset of the files in your project by entering a glob pattern into the \"File/Directory pattern\" text box. For example, the pattern src/*.js would restrict the search to javascript files in the src directory. The \"globstar\" pattern (**) can be used to match arbitrarily many subdirectories. For example, docs/**/*.md will match docs/a/foo.md, docs/a/b/foo.md, etc. When you have multiple project folders open, this feature can also be used to search in only one of those folders. For example, if you had the folders /path1/folder1 and /path2/folder2 open, you could enter a pattern starting with folder1 to search only in the first folder. Press Esc while focused on the Find and Replace panel to clear the pane from your workspace. The Find and Replace functionality is implemented in the find-and-replace package and uses the scandal Node module to do the actual searching.",
          "excerpt": " Find and Replace Finding and replacing text in your file or project is quick and easy in Atom.   Cmd+FCtrl+F - Search within a buffer  Cmd+S…"
        },
      
    
      
        
        {
          "title": "Panes",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/panes/",
          "body": " Panes You can split any editor pane horizontally or vertically by using Cmd+KCtrl+K Up/Down/Left/Right where the direction key is the direction to split the pane. Once you have a split pane, you can switch between them with Cmd+KCtrl+K Cmd+Up/Down/Left/RightCtrl+Up/Down/Left/Right where the direction is the direction the focus should move to.  Each pane has its own \"pane items\", which are represented by tabs. You can move the files from pane to pane by dragging them with the mouse and dropping them in the pane you want that file to be in.  If you don't like using tabs, you don't have to. You can disable the tabs package and each pane will still support multiple pane items. You just won't have tabs to use to click between them.  To close a pane, you can close all pane items with Cmd+WCtrl+W. You can configure whether panes auto-close when empty in the Settings View with the \"Remove Empty Panes\" setting under Core Settings.",
          "excerpt": " Panes You can split any editor pane horizontally or vertically by using Cmd+KCtrl+K Up/Down/Left/Right where the direction key is the direct…"
        },
      
    
      
        
        {
          "title": "Summary",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/summary/",
          "body": " Summary At this point you should be something of an Atom master user. You should be able to navigate and manipulate your text and files like a wizard. You should also be able to customize Atom backwards and forwards to make it look and act just how you want it to. In the next chapter, we're going to kick it up a notch: we'll take a look at changing and adding new functionality to the core of Atom itself. We're going to start creating packages for Atom. If you can dream it, you can build it.",
          "excerpt": " Summary At this point you should be something of an Atom master user. You should be able to navigate and manipulate your text and files like…"
        },
      
    
      
        
        {
          "title": "Moving in Atom",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/moving-in-atom/",
          "body": " Moving in Atom While it's pretty easy to move around Atom by clicking with the mouse or using the arrow keys, there are some keybindings that may help you keep your hands on the keyboard and navigate around a little faster.  Atom ships with many of the basic Emacs keybindings for navigating a document. To go up and down a single character, you can use Ctrl+P and Ctrl+N. To go left and right a single character, you can use Ctrl+B and Ctrl+F. These are the equivalent of using the arrow keys, though some people prefer not having to move their hands to where the arrow keys are located on their keyboard. In addition to single character movement, there are a number of other movement keybindings:   Atom has support for all the standard Windows cursor movement key combinations. To go up, down, left or right a single character you can use the arrow keys. In addition to single character movement, there are a number of other movement keybindings:   Atom has support for all the standard Linux cursor movement key combinations. To go up, down, left or right a single character you can use the arrow keys. In addition to single character movement, there are a number of other movement keybindings:    Alt+Left or Alt+BCtrl+Left - Move to the beginning of word  Alt+Right or Alt+FCtrl+Right - Move to the end of word  Cmd+Left or Ctrl+AHome - Move to the first character of the current line  Cmd+Right or Ctrl+EEnd - Move to the end of the line  Cmd+UpCtrl+Home - Move to the top of the file  Cmd+DownCtrl+End - Move to the bottom of the file  You can also move directly to a specific line (and column) number with Ctrl+G. This will bring up a dialog that asks which line you would like to jump to. You can also use the row:column syntax to jump to a character in that line as well.   Navigating by Symbols You can also jump around a little more informatively with the Symbols View. To jump to a symbol such as a method definition, press Cmd+RCtrl+R. This opens a list of all symbols in the current file, which you can fuzzy filter similarly to Cmd+TCtrl+T. You can also search for symbols across your project but it requires a tags file.  You can generate a tags file by using the ctags utility. Once it is installed, you can use it to generate a tags file by running a command to generate it. See the ctags documentation for details.  Once you have your tags file generated, you can use it to search for symbols across your project by pressing Cmd+Shift+R. This also enables you to use Alt+Cmd+Down to go to and Alt+Cmd+Up to return from the declaration of the symbol under the cursor.   Once you have your tags file generated, you can use it to search for symbols across your project by pressing Ctrl+Shift+R. This also enables you to use Alt+Ctrl+Down to go to and Alt+Ctrl+Up to return from the declaration of the symbol under the cursor.   Once you have your tags file generated, you can use it to search for symbols across your project by pressing Cmd+Shift+RCtrl+Shift+R.  You can customize how tags are generated by creating your own .ctags file in your home directory, ~/.ctags%USERPROFILE%\\.ctags. An example can be found here. The symbols navigation functionality is implemented in the symbols-view package.  Bookmarks Atom also has a great way to bookmark specific lines in your project so you can jump back to them quickly. If you press Cmd+F2Alt+Ctrl+F2Ctrl+Shift+F2, Atom will toggle a \"bookmark\" on the current line. You can set these throughout your project and use them to quickly find and jump to important lines of your project. A small bookmark symbol is added to the line gutter, like on line 22 of the image below. If you hit F2, Atom will jump to the next bookmark in the file you currently have focused. If you use Shift+F2 it will cycle backwards through them instead. You can also see a list of all your project's current bookmarks and quickly filter them and jump to any of them by hitting Ctrl+F2.   The bookmarks functionality is implemented in the bookmarks package.",
          "excerpt": " Moving in Atom While it's pretty easy to move around Atom by clicking with the mouse or using the arrow keys, there are some keybindings tha…"
        },
      
    
      
        
        {
          "title": "Grammar",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/grammar/",
          "body": " Grammar The \"grammar\" of a file is what language Atom has associated with that file. Types of grammars would include \"Java\" or \"GitHub-Flavored Markdown\". We looked at this a bit when we created some snippets in Snippets. When you load a file, Atom does a little work to try to figure out what type of file it is. Largely this is accomplished by looking at its file extension (.md is generally a Markdown file, etc), though sometimes it has to inspect the content a bit to figure it out. When you open a file and Atom can't determine a grammar for the file, it will default to \"Plain Text\", which is the simplest one. If it does default to \"Plain Text\", picks the wrong grammar for the file, or if for any reason you wish to change the selected grammar, you can pull up the Grammar Selector with Ctrl+Shift+L.  When the grammar of a file is changed, Atom will remember that for the current session. The Grammar Selector functionality is implemented in the grammar-selector package.",
          "excerpt": " Grammar The \"grammar\" of a file is what language Atom has associated with that file. Types of grammars would include \"Java\" or \"GitHub-…"
        },
      
    
      
        
        {
          "title": "Writing in Atom",
          "category": "",
          "category_url": "",
          "url": "/using-atom/sections/writing-in-atom/",
          "body": " Writing in Atom Though it is probably most common to use Atom to write software code, Atom can also be used to write prose quite effectively. Most often this is done in some sort of markup language such as Asciidoc or Markdown (in which this manual is written). Here we'll quickly cover a few of the tools Atom provides for helping you write prose. In these docs, we'll concentrate on writing in Markdown; however, other prose markup languages like Asciidoc have packages that provide similar functionality.  Spell Checking If you're working in text (which includes plain text files, GitHub markdown, and Git commit messages by default), Atom will automatically try to check your spelling. Any misspelled words will be highlighted (by default with a dashed red line beneath the word), and you can pull up a menu of possible corrections by hitting Cmd+Shift+;Ctrl+Shift+; (or by choosing \"Correct Spelling\" from the right-click context menu or from the Command Palette).  To add more types of files to the list of what Atom will try to spell check, go to the Spell Check package settings in your Settings view and add any grammars you want to spell check. The default grammars to spell check are text.plain, source.gfm, and text.git-commit but you can add something like source.asciidoc if you wish to check those types of files too. The spell checking is implemented in the spell-check package.  Previews When writing prose in a markup language, it's often very useful to get an idea of what the content will look like when it's rendered. Atom ships with a package for previewing Markdown by default.   Ctrl+Shift+M - Will toggle Preview mode for Markdown.   As you edit the text, the preview will also update automatically. This makes it fairly easy to check your syntax as you type. You can also copy the rendered HTML from the preview pane into your system clipboard. There is no keybinding for it, but you can find it in the Command Palette by searching for \"Markdown Preview Copy HTML\". Markdown preview is implemented in the markdown-preview package.  Snippets There are also a number of great snippets available for writing Markdown quickly. If you type img and hit tab you get a Markdown-formatted image embed code like ![](). If you type table and hit tab you get a nice example table to fill out. | Header One | Header Two | | :------------- | :------------- | | Item One | Item Two |  Although there are only a handful of Markdown snippets (b for bold, i for italic, code for a code block, etc), they save you from having to look up the more obscure syntaxes. Again, you can easily see a list of all available snippets for the type of file you're currently in by choosing \"Snippets: Available\" in the Command Palette.",
          "excerpt": " Writing in Atom Though it is probably most common to use Atom to write software code, Atom can also be used to write prose quite effectively…"
        },
      
    
      
        
        {
          "title": "Upgrading Your Syntax Theme",
          "category": "",
          "category_url": "",
          "url": "/upgrading-to-1-0-apis/sections/upgrading-your-syntax-theme/",
          "body": " Note: The Shadow DOM was removed in Atom 1.13. The :host selector described below won't work and should not be used anymore.   Upgrading Your Syntax Theme Text editor content is now rendered in the shadow DOM, which shields it from being styled by global style sheets to protect against accidental style pollution. For more background on the shadow DOM, check out the Shadow DOM 101 on HTML 5 Rocks. Syntax themes are specifically intended to style only text editor content, so they are automatically loaded directly into the text editor's shadow DOM when it is enabled. This happens automatically when the theme's package.json contains a theme: \"syntax\" declaration, so you don't need to change anything to target the appropriate context. When theme style sheets are loaded into the text editor's shadow DOM, selectors intended to target the editor from the outside no longer make sense. Styles targeting the .editor and .editor-colors classes instead need to target the :host pseudo-element, which matches against the containing atom-text-editor node. Check out the Shadow DOM 201 article for more information about the :host pseudo-element. Here's an example from Atom's light syntax theme. Note that the atom-text-editor selector intended to target the editor from the outside has been retained to allow the theme to keep working during the transition phase when it is possible to disable the shadow DOM. atom-text-editor, :host { /* :host added */ background-color: @syntax-background-color; color: @syntax-text-color; .invisible-character { color: @syntax-invisible-character-color; } /* more nested selectors... */ } ",
          "excerpt": " Note: The Shadow DOM was removed in Atom 1.13. The :host selector described below won't work and should not be used anymore.   Upgrading You…"
        },
      
    
      
        
        {
          "title": "Upgrading Your Package",
          "category": "",
          "category_url": "",
          "url": "/upgrading-to-1-0-apis/sections/upgrading-your-package/",
          "body": " Upgrading Your Package This document will guide you through the large bits of upgrading your package to work with 1.0 APIs.  TL;DR We've set deprecation messages and errors in strategic places to help make sure you don't miss anything. You should be able to get 95% of the way to an updated package just by fixing errors and deprecations. There are a couple of things you can do to get the full effect of all the errors and deprecations.  Use atom-space-pen-views If you use any class from require 'atom' with a $ or View in the name, add the atom-space-pen-views module to your package's package.json file's dependencies: { \"dependencies\": { \"atom-space-pen-views\": \"^2.0.3\" } }  Then run apm install in your package directory.  Require views from atom-space-pen-views Anywhere you are requiring one of the following from atom you need to require them from atom-space-pen-views instead. # require these from 'atom-space-pen-views' rather than 'atom' $ $$ $$$ View TextEditorView ScrollView SelectListView  So this: # Old way {$, TextEditorView, View, GitRepository} = require 'atom'  Would be replaced by this: # New way {GitRepository} = require 'atom' {$, TextEditorView, View} = require 'atom-space-pen-views'   Run specs and test your package You wrote specs, right!? Here's where they shine. Run them with cmd-shift-P, and search for run package specs. It will show all the deprecation messages and errors.  Update the engines field When you are deprecation free and all done converting, upgrade the engines field in your package.json: { \"engines\": { \"atom\": \"&gt;=0.174.0 &lt;2.0.0\" } }   Examples We have upgraded all the core packages. Please see this issue for a link to all the upgrade PRs.  Deprecations All of the methods in Atom core that have changes will emit deprecation messages when called. These messages are shown in two places: your package specs, and in Deprecation Cop.  Specs Just run your specs, and all the deprecations will be displayed in yellow.   Note: Deprecations are only displayed when executing specs through the \"Window: Run Package Specs\" command in the Atom UI. Deprecations are not displayed when running specs at the terminal.   Deprecation Cop Run Atom in Dev Mode, atom --dev, with your package loaded, and open Deprecation Cop (search for \"deprecation\" in the command palette). Deprecated methods will appear in Deprecation Cop only after they have been called.  When Deprecation Cop is open, and deprecated methods are called, a Refresh button will appear in the top right of the Deprecation Cop interface. So exercise your package, then come back to Deprecation Cop and click the Refresh button.  Upgrading your Views Previous to 1.0, views were baked into Atom core. These views were based on jQuery and space-pen. They looked something like this: # The old way: getting views from atom {$, TextEditorView, View} = require 'atom' module.exports = class SomeView extends View @content: -&gt; @div class: 'find-and-replace', =&gt; @div class: 'block', =&gt; @subview 'myEditor', new TextEditorView(mini: true) #...   The New require 'atom' no longer provides view helpers or jQuery. Atom Core is now 'view agnostic'. The preexisting view system is available from a new Node module: atom-space-pen-views. atom-space-pen-views now provides jQuery, space-pen views, and Atom specific views: # These are now provided by atom-space-pen-views $ $$ $$$ View TextEditorView ScrollView SelectListView   Adding the module dependencies To use the new views, you need to specify the atom-space-pen-views module in your package's package.json file's dependencies: { \"dependencies\": { \"atom-space-pen-views\": \"^2.0.3\" } }  space-pen bundles jQuery. If you do not need space-pen or any of the views, you can require jQuery directly. { \"dependencies\": { \"jquery\": \"^2\" } }   Converting your views Sometimes it is as simple as converting the requires at the top of each view page. I assume you read the 'TL;DR' section and have updated all of your requires.  Upgrading classes extending any space-pen View  afterAttach and beforeRemove updated The afterAttach and beforeRemove hooks have been replaced with attached and detached and the semantics have changed. afterAttach was called whenever the node was attached to another DOM node, even if that parent node wasn't present in the DOM. afterAttach also was called with a boolean indicating whether or not the element and its parents were on the DOM. Now the attached hook is only called when the node and all of its parents are actually on the DOM, and is not called with a boolean. beforeRemove was only called when $.fn.remove was called, which was typically used when the node was completely removed from the DOM. The new detached hook is called whenever the DOM node is detached, which could happen if the node is being detached for reattachment later. In short, if beforeRemove is called the node is never coming back. With detached it might be attached again later. # Old way {View} = require 'atom' class MyView extends View afterAttach: (onDom) -&gt; #... beforeRemove: -&gt; #...  # New way {View} = require 'atom-space-pen-views' class MyView extends View attached: -&gt; # Always called with the equivalent of @afterAttach(true)! #... detached: -&gt; #...   subscribe and subscribeToCommand methods removed The subscribe and subscribeToCommand methods have been removed. See the Eventing and Disposables section for more info.  Upgrading to the new TextEditorView All of the atom-specific methods available on the TextEditorView have been moved to the TextEditor, available via TextEditorView::getModel. See the TextEditorView docs and TextEditor docs for more info.  Upgrading classes extending ScrollView The ScrollView has very minor changes. You can no longer use @off to remove default behavior for core:move-up, core:move-down, etc. # Old way to turn off default behavior class ResultsView extends ScrollView initialize: (@model) -&gt; super() # turn off default scrolling behavior from ScrollView @off 'core:move-up' @off 'core:move-down' @off 'core:move-left' @off 'core:move-right'  # New way to turn off default behavior class ResultsView extends ScrollView initialize: (@model) -&gt; disposable = super() # turn off default scrolling behavior from ScrollView disposable.dispose()   Check out an example from find-and-replace. See the docs for all the options.   Upgrading classes extending SelectListView Your SelectListView might look something like this: # Old! class CommandPaletteView extends SelectListView initialize: -&gt; super() @addClass('command-palette overlay from-top') atom.workspaceView.command 'command-palette:toggle', =&gt; @toggle() confirmed: ({name, jQuery}) -&gt; @cancel() # do something with the result toggle: -&gt; if @hasParent() @cancel() else @attach() attach: -&gt; @storeFocusedElement() items = [] # TODO: build items @setItems(items) atom.workspaceView.append(this) @focusFilterEditor() confirmed: ({name, jQuery}) -&gt; @cancel()  This attaches and detaches itself from the DOM when toggled, canceling magically detaches it from the DOM, and it uses the classes overlay and from-top. The new SelectListView no longer automatically detaches itself from the DOM when cancelled. It's up to you to implement whatever cancel behavior you want. Using the new APIs to mimic the semantics of the old class, it should look like this: # New! class CommandPaletteView extends SelectListView initialize: -&gt; super() # no more need for the `overlay` and `from-top` classes @addClass('command-palette') atom.commands.add 'atom-workspace', 'command-palette:toggle', =&gt; @toggle() # You need to implement the `cancelled` method and hide. cancelled: -&gt; @hide() confirmed: ({name, jQuery}) -&gt; @cancel() # do something with the result toggle: -&gt; # Toggling now checks panel visibility, # and hides / shows rather than attaching to / detaching from the DOM. if @panel?.isVisible() @cancel() else @show() show: -&gt; # Now you will add your select list as a modal panel to the workspace @panel ?= atom.workspace.addModalPanel(item: this) @panel.show() @storeFocusedElement() items = [] # TODO: build items @setItems(items) @focusFilterEditor() hide: -&gt; @panel?.hide()   And check out the conversion of CommandPaletteView as a real-world example. See the SelectListView docs for all options.   Using the model layer rather than the view layer The API no longer exposes any specialized view objects or view classes. atom.workspaceView, and all the view classes: WorkspaceView, EditorView, PaneView, etc. have been globally deprecated. Nearly all of the atom-specific actions performed by the old view objects can now be managed via the model layer. For example, here's adding a panel to the interface using the atom.workspace model instead of the workspaceView: # Old! div = document.createElement('div') atom.workspaceView.appendToTop(div)  # New! div = document.createElement('div') atom.workspace.addTopPanel(item: div)  For actions that still require the view, such as dispatching commands or munging css classes, you'll access the view via the atom.views.getView() method. This will return a subclass of HTMLElement rather than a jQuery object or an instance of a deprecated view class (e.g. WorkspaceView). # Old! workspaceView = atom.workspaceView editorView = workspaceView.getActiveEditorView() paneView = editorView.getPaneView()  # New! # Generally, just use the models workspace = atom.workspace editor = workspace.getActiveTextEditor() pane = editor.getPane() # If you need views, get them with `getView` workspaceElement = atom.views.getView(atom.workspace) editorElement = atom.views.getView(editor) paneElement = atom.views.getView(pane)   Updating Specs atom.workspaceView, the WorkspaceView class and the EditorView class have been deprecated. These two objects are used heavily throughout specs, mostly to dispatch events and commands. This section will explain how to remove them while still retaining the ability to dispatch events and commands.  Removing WorkspaceView references WorkspaceView has been deprecated. Everything you could do on the view, you can now do on the Workspace model. Requiring WorkspaceView from atom and accessing any methods on it will throw a deprecation warning. Many specs lean heavily on WorkspaceView to trigger commands and fetch EditorView objects. Your specs might contain something like this: # Old! {WorkspaceView} = require 'atom' describe 'FindView', -&gt; beforeEach -&gt; atom.workspaceView = new WorkspaceView()  Instead, we will use the atom.views.getView() method. This will return a plain HTMLElement, not a WorkspaceView or jQuery object. # New! describe 'FindView', -&gt; workspaceElement = null beforeEach -&gt; workspaceElement = atom.views.getView(atom.workspace)   Attaching the workspace to the DOM The workspace needs to be attached to the DOM in some cases. For example, view hooks only work (attached() on View, attachedCallback() on custom elements) when there is a descendant attached to the DOM. You might see this in your specs: # Old! atom.workspaceView.attachToDom()  Change it to: # New! jasmine.attachToDOM(workspaceElement)   Removing EditorView references Like WorkspaceView, EditorView has been deprecated. Everything you needed to do on the view you are now able to do on the TextEditor model. In many cases, you will not even need to get the editor's view anymore. Any of those instances should be updated to use the TextEditor instance instead. You should really only need the editor's view when you plan on triggering a command on the view in a spec. Your specs might contain something like this: # Old! describe 'Something', -&gt; [editorView] = [] beforeEach -&gt; editorView = atom.workspaceView.getActiveView()  We're going to use atom.views.getView() again to get the editor element. As in the case of the workspaceElement, getView will return a subclass of HTMLElement rather than an EditorView or jQuery object. # New! describe 'Something', -&gt; [editor, editorElement] = [] beforeEach -&gt; editor = atom.workspace.getActiveTextEditor() editorElement = atom.views.getView(editor)   Dispatching commands Since the editorElement objects are no longer jQuery objects, they no longer support trigger(). Additionally, Atom has a new command dispatcher, atom.commands, that we use rather than commandeering jQuery's trigger method. From this: # Old! workspaceView.trigger 'a-package:toggle' editorView.trigger 'find-and-replace:show'  To this: # New! atom.commands.dispatch workspaceElement, 'a-package:toggle' atom.commands.dispatch editorElement, 'find-and-replace:show'   Eventing and Disposables A couple large things changed with respect to events:  All model events are now exposed as event subscription methods that return Disposable objects The subscribe() method is no longer available on space-pen View objects An Emitter is now provided from require 'atom'    Consuming Events All events from the Atom API are now methods that return a Disposable object, on which you can call dispose() to unsubscribe. # Old! editor.on 'changed', -&gt;  # New! disposable = editor.onDidChange -&gt; # You can unsubscribe at some point in the future via `dispose()` disposable.dispose()  Deprecation warnings will guide you toward the correct methods.  Using a CompositeDisposable  You can group multiple disposables into a single disposable with a CompositeDisposable. {CompositeDisposable} = require 'atom' class Something constructor: -&gt; editor = atom.workspace.getActiveTextEditor() @disposables = new CompositeDisposable @disposables.add editor.onDidChange -&gt; @disposables.add editor.onDidChangePath -&gt; destroy: -&gt; @disposables.dispose()   Removing View::subscribe and Subscriber::subscribe calls There were a couple permutations of subscribe(). In these examples, a CompositeDisposable is used as it will commonly be useful where conversion is necessary.  subscribe(unsubscribable)  This one is very straight forward. # Old! @subscribe editor.on 'changed', -&gt;  # New! disposables = new CompositeDisposable disposables.add editor.onDidChange -&gt;   subscribe(modelObject, event, method)  When the modelObject is an Atom model object, the change is very simple. Just use the correct event method, and add it to your CompositeDisposable. # Old! @subscribe editor, 'changed', -&gt;  # New! disposables = new CompositeDisposable disposables.add editor.onDidChange -&gt;   subscribe(jQueryObject, selector(optional), event, method)  Things are a little more complicated when subscribing to a DOM or jQuery element. Atom no longer provides helpers for subscribing to elements. You can use jQuery or the native DOM APIs, whichever you prefer. # Old! @subscribe $(window), 'focus', -&gt;  # New! {Disposable, CompositeDisposable} = require 'atom' disposables = new CompositeDisposable # New with jQuery focusCallback = -&gt; $(window).on 'focus', focusCallback disposables.add new Disposable -&gt; $(window).off 'focus', focusCallback # New with native APIs focusCallback = -&gt; window.addEventListener 'focus', focusCallback disposables.add new Disposable -&gt; window.removeEventListener 'focus', focusCallback   Providing Events: Using the Emitter  You no longer need to require emissary to get an emitter. We now provide an Emitter class from require 'atom'. We have a specific pattern for use of the Emitter. Rather than mixing it in, we instantiate a member variable, and create explicit subscription methods. For more information see the Emitter docs. # New! {Emitter} = require 'atom' class Something constructor: -&gt; @emitter = new Emitter destroy: -&gt; @emitter.dispose() onDidChange: (callback) -&gt; @emitter.on 'did-change', callback methodThatFiresAChange: -&gt; @emitter.emit 'did-change', {data: 2} # Using the evented class something = new Something something.onDidChange (eventObject) -&gt; console.log eventObject.data # =&gt; 2 something.methodThatFiresAChange()   Subscribing To Commands $.fn.command and View::subscribeToCommand are no longer available. Now we use atom.commands.add, and collect the results in a CompositeDisposable. See the docs for more info. # Old! atom.workspaceView.command 'core:close core:cancel', -&gt; # When inside a View class, you might see this @subscribeToCommand 'core:close core:cancel', -&gt;  # New! @disposables.add atom.commands.add 'atom-workspace', 'core:close': -&gt; 'core:cancel': -&gt; # You can register commands directly on individual DOM elements in addition to # using selectors. When in a View class, you should have a `@element` object # available. `@element` is a plain HTMLElement object @disposables.add atom.commands.add @element, 'core:close': -&gt; 'core:cancel': -&gt;   Upgrading your stylesheet's selectors Many selectors have changed, and we have introduced the Shadow DOM to the editor. See the Upgrading Your UI Theme And Package Selectors guide for more information in upgrading your package stylesheets.",
          "excerpt": " Upgrading Your Package This document will guide you through the large bits of upgrading your package to work with 1.0 APIs.  TL;DR We've set…"
        },
      
    
      
        
        {
          "title": "Upgrading Your UI Theme Or Package Selectors",
          "category": "",
          "category_url": "",
          "url": "/upgrading-to-1-0-apis/sections/upgrading-your-ui-theme-or-package-selectors/",
          "body": " Note: The Shadow DOM was removed in Atom 1.13. The ::shadow and /deep/ selectors and the context-targeted style sheets described below won't work and should not be used anymore.   Upgrading Your UI Theme Or Package Selectors In addition to changes in Atom's scripting API, we'll also be making some breaking changes to Atom's DOM structure, requiring style sheets and keymaps in both packages and themes to be updated.  Deprecation Cop Deprecation Cop will list usages of deprecated selector patterns to guide you. You can access it via the Command Palette (cmd-shift-p, then search for Deprecation). It breaks the deprecations down by package:   Custom Tags Rather than adding classes to standard HTML elements to indicate their role, Atom now uses custom element names. For example, &lt;div class=\"workspace\"&gt; has now been replaced with &lt;atom-workspace&gt;. Selectors should be updated accordingly. Note that tag names have lower specificity than classes in CSS, so you'll need to take care in converting things.    Old Selector New Selector     .editor atom-text-editor   .editor.mini atom-text-editor[mini]   .workspace atom-workspace   .horizontal atom-workspace-axis.horizontal   .vertical atom-workspace-axis.vertical   .pane-container atom-pane-container   .pane atom-pane   .tool-panel atom-panel   .panel-top atom-panel.top   .panel-bottom atom-panel.bottom   .panel-left atom-panel.left   .panel-right atom-panel.right   .overlay atom-panel.modal     Supporting the Shadow DOM Text editor content is now rendered in the shadow DOM, which shields it from being styled by global style sheets to protect against accidental style pollution. For more background on the shadow DOM, check out the Shadow DOM 101 on HTML 5 Rocks. If you need to style text editor content in a UI theme, you'll need to circumvent this protection for any rules that target the text editor's content. Some examples of the kinds of UI theme styles needing to be updated:  Highlight decorations Gutter decorations Line decorations Scrollbar styling Anything targeting a child selector of .editor   During a transition phase, it will be possible to enable or disable the text editor's shadow DOM in the settings, so themes will need to be compatible with both approaches.  Shadow DOM Selectors Chromium provides two tools for bypassing shadow boundaries, the ::shadow pseudo-element and the /deep/ combinator. For an in-depth explanation of styling the shadow DOM, see the Shadow DOM 201 article on HTML 5 Rocks.  ::shadow  The ::shadow pseudo-element allows you to bypass a single shadow root. For example, say you want to update a highlight decoration for a linter package. Initially, the style looks as follows: // Without shadow DOM support atom-text-editor .highlight.my-linter { background: hotpink; }  In order for this style to apply with the shadow DOM enabled, you will need to add a second selector with the ::shadow pseudo-element. You should leave the original selector in place so your theme continues to work with the shadow DOM disabled during the transition period. // With shadow DOM support atom-text-editor .highlight.my-linter, atom-text-editor::shadow .highlight.my-linter { background: hotpink; }  Check out the find-and-replace package for another example of using ::shadow to pierce the shadow DOM.  /deep/  The /deep/ combinator overrides all shadow boundaries, making it useful for rules you want to apply globally such as scrollbar styling. Here's a snippet containing scrollbar styling for the Atom Dark UI theme before shadow DOM support: // Without shadow DOM support .scrollbars-visible-always { ::-webkit-scrollbar { width: 8px; height: 8px; } ::-webkit-scrollbar-track, ::-webkit-scrollbar-corner { background: @scrollbar-background-color; } ::-webkit-scrollbar-thumb { background: @scrollbar-color; border-radius: 5px; box-shadow: 0 0 1px black inset; } }  To style scrollbars even inside of the shadow DOM, each rule needs to be prefixed with /deep/. We use /deep/ instead of ::shadow because we don't care about the selector of the host element in this case. We just want our styling to apply everywhere. // With shadow DOM support using /deep/ .scrollbars-visible-always { /deep/ ::-webkit-scrollbar { width: 8px; height: 8px; } /deep/ ::-webkit-scrollbar-track, /deep/ ::-webkit-scrollbar-corner { background: @scrollbar-background-color; } /deep/ ::-webkit-scrollbar-thumb { background: @scrollbar-color; border-radius: 5px; box-shadow: 0 0 1px black inset; } }   Context-Targeted Style Sheets The selector features discussed above allow you to target shadow DOM content with specific selectors, but Atom also allows you to target a specific shadow DOM context with an entire style sheet. The context into which a style sheet is loaded is based on the file name. If you want to load a style sheet into the editor, name it with the .atom-text-editor.less or .atom-text-editor.css extensions. my-ui-theme/ styles/ index.less # loaded globally index.atom-text-editor.less # loaded in the text editor shadow DOM  Check out this style sheet from the decoration-example package for an example of context-targeting. Inside a context-targeted style sheet, there's no need to use the ::shadow or /deep/ expressions. If you want to refer to the element containing the shadow root, you can use the ::host pseudo-element. During the transition phase, style sheets targeting the atom-text-editor context will also be loaded globally. Make sure you update your selectors in a way that maintains compatibility with the shadow DOM being disabled. That means if you use a ::host pseudo element, you should also include the same style rule matches against atom-text-editor.",
          "excerpt": " Note: The Shadow DOM was removed in Atom 1.13. The ::shadow and /deep/ selectors and the context-targeted style sheets described below won't…"
        },
      
    
      
        
        {
          "title": "Package: Active Editor Info",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/package-active-editor-info/",
          "body": " Package: Active Editor Info We saw in our Word Count package how we could show information in a modal panel. However, panels aren't the only way to extend Atom's UI—you can also add items to the workspace. These items can be dragged to new locations (for example, one of the docks on the edges of the window), and Atom will restore them the next time you open the project. This system is used by Atom's tree view, as well as by third party packages like Nuclide for its console, debugger, outline view, and diagnostics (linter results). For this package, we'll define a workspace item that tells us some information about our active text editor. The final package can be viewed at https://github.com/atom/active-editor-info.  Create the Package To begin, press Cmd+Shift+PCtrl+Shift+P to bring up the Command Palette. Type \"generate package\" and select the \"Package Generator: Generate Package\" command, just as we did in the section on package generation. Enter active-editor-info as the name of the package.  Add an Opener Now let's edit the package files to show our view in a workspace item instead of a modal panel. The way we do this is by registering an opener with Atom. Openers are just functions that accept a URI and return a view (if it's a URI that the opener knows about). When you call atom.workspace.open(), Atom will go through all of its openers until it finds one that can handle the URI you passed. Let's open lib/active-editor-info.js and edit our activate() method to register an opener: 'use babel'; import ActiveEditorInfoView from './active-editor-info-view'; import {CompositeDisposable, Disposable} from 'atom'; export default { subscriptions: null, activate(state) { this.subscriptions = new CompositeDisposable( // Add an opener for our view. atom.workspace.addOpener(uri =&gt; { if (uri === 'atom://active-editor-info') { return new ActiveEditorInfoView(); } }), // Register command that toggles this view atom.commands.add('atom-workspace', { 'active-editor-info:toggle': () =&gt; this.toggle() }), // Destroy any ActiveEditorInfoViews when the package is deactivated. new Disposable(() =&gt; { atom.workspace.getPaneItems().forEach(item =&gt; { if (item instanceof ActiveEditorInfoView) { item.destroy(); } }); }) ); }, deactivate() { this.subscriptions.dispose(); }, toggle() { console.log('Toggle it!') } };  You'll notice we also removed the activeEditorInfoView property and the serialize() method. That's because, with workspace items, it's possible to have more than one instance of a given view. Since each instance can have its own state, each should do its own serialization instead of relying on a package-level serialize() method. We'll come back to that later. You probably also noticed that our toggle() implementation just logs the text \"Toggle it!\" to the console. Let's make it actually toggle our view:  toggle() { atom.workspace.toggle('atom://active-editor-info'); }   Updating the View Atom uses the same view abstractions everywhere, so we can almost use the generated ActiveEditorInfoView class as-is. We just need to add two small methods:  getTitle() { // Used by Atom for tab text return 'Active Editor Info'; } getURI() { // Used by Atom to identify the view when toggling. return 'atom://active-editor-info'; }  Now reload the window and run the \"Active Editor Info: Toggle\" command from the command palette! Our view will appear in a new tab in the center of the workspace. If you want, you can drag it into one of the docks. Toggling it again will then hide that dock. If you close the tab and run the toggle command again, it will appear in the last place you had it.  We've repeated the same URI three times now. That's okay, but it's probably a good idea to define the URL in one place and then import it from that module wherever you need it.   Constraining Our Item's Locations The purpose of our view is to show information about the active text editor, so it doesn't really make sense to show our item in the center of the workspace (where the text editor will be). Let's add some methods to our view class to influence where its opened:  getDefaultLocation() { // This location will be used if the user hasn't overridden it by dragging the item elsewhere. // Valid values are \"left\", \"right\", \"bottom\", and \"center\" (the default). return 'right'; } getAllowedLocations() { // The locations into which the item can be moved. return ['left', 'right', 'bottom']; }  Now our item will appear in the right dock intially and users will only be able to drag it to one of the other docks.  Show Active Editor Info Now that we have our view all wired up, let's update it to show some information about the active text editor. Add this to the constructor: this.subscriptions = atom.workspace.getCenter().observeActivePaneItem(item =&gt; { if (!atom.workspace.isTextEditor(item)) { message.innerText = 'Open a file to see important information about it.'; return; } message.innerHTML = ` &lt;h2&gt;${item.getFileName() || 'untitled'}&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;b&gt;Soft Wrap:&lt;/b&gt; ${item.softWrapped}&lt;/li&gt; &lt;li&gt;&lt;b&gt;Tab Length:&lt;/b&gt; ${item.getTabLength()}&lt;/li&gt; &lt;li&gt;&lt;b&gt;Encoding:&lt;/b&gt; ${item.getEncoding()}&lt;/li&gt; &lt;li&gt;&lt;b&gt;Line Count:&lt;/b&gt; ${item.getLineCount()}&lt;/li&gt; &lt;/ul&gt; `; });  Now whenever you open a text editor in the center, the view will update with some information about it.  We use a template string here because it's simple and we have a lot of control over what's going into it, but this could easily result in the insertion of unwanted HTML if you're not careful. Sanitize your input and use the DOM API or a templating system when doing this for real.  Also, don't forget to clean up the subscription in the destroy() method: destroy() { this.element.remove(); this.subscriptions.dispose(); }   Serialization If you were to reload Atom now, you'd see that our item had disappeared. That's because we haven't told Atom how to serialize it yet. Let's do that now. The first step is to implement a serialize() method on our ActiveEditorInfoView class. Atom will call the serialize() method on every item in the workspace periodically to save its state.  serialize() { return { // This is used to look up the deserializer function. It can be any string, but it needs to be // unique across all packages! deserializer: 'active-editor-info/ActiveEditorInfoView' }; }   All of our view's state is derived from the active text editor so we only need the deserializer field. If we had other state that we wanted to preserve across reloads, we would just add things to the object we're returning. Just make sure that they're JSON serializable!  Next we need to register a deserializer function that Atom can use to recreate the real object when it starts up. The best way to do that is to add a \"deserializers\" object to our package.json file: { \"name\": \"active-editor-info\", ... \"deserializers\": { \"active-editor-info/ActiveEditorInfoView\": \"deserializeActiveEditorInfoView\" } }  Notice that the key (\"active-editor-info/ActiveEditorInfoView\") matches the string we used in our serialize() method above. The value (\"deserializeActiveEditorInfoView\") refers to a function in our main module, which we still need to add. Go back to active-editor-info.js and do that now:  deserializeActiveEditorInfoView(serialized) { return new ActiveEditorInfoView(); }  The value returned from our serialize() method will be passed to this function. Since our serialized object didn't include any state, we can just return a new ActiveEditorInfoView instance. Reload Atom and toggle the view with the \"Active Editor Info: Toggle\" command. Then reload Atom again. Your view should be just where you left it!  Summary In this section, we've made a toggleable workspace item whose placement can be controlled by the user. This could be helpful when creating all sorts of visual tools for working with code!",
          "excerpt": " Package: Active Editor Info We saw in our Word Count package how we could show information in a modal panel. However, panels aren't the only…"
        },
      
    
      
        
        {
          "title": "Tools of the Trade",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/tools-of-the-trade/",
          "body": " Tools of the Trade To begin, there are a few things we'll assume you know, at least to some degree. Since all of Atom is implemented using web technologies, we have to assume you know web technologies such as JavaScript and CSS. Specifically, we'll be implementing everything in CoffeeScript and Less, which are preprocessors for Javascript and CSS respectively. If you don't know CoffeeScript, but you are familiar with JavaScript, you shouldn't have too much trouble. Here is an example of some simple CoffeeScript code: MyPackageView = require './my-package-view' module.exports = myPackageView: null activate: (state) -&gt; @myPackageView = new MyPackageView(state.myPackageViewState) deactivate: -&gt; @myPackageView.destroy() serialize: -&gt; myPackageViewState: @myPackageView.serialize()  We'll go over examples like this in a bit, but this is what the language looks like. Just about everything you can do with CoffeeScript in Atom is also doable in JavaScript. You can brush up on CoffeeScript at coffeescript.org. Less is an even simpler transition from CSS. It adds a number of useful things like variables and functions to CSS. You can learn about Less at lesscss.org. Our usage of Less won't get too complex in this book however, so as long as you know basic CSS you should be fine.",
          "excerpt": " Tools of the Trade To begin, there are a few things we'll assume you know, at least to some degree. Since all of Atom is implemented using w…"
        },
      
    
      
        
        {
          "title": "Cross-Platform Compatibility",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/cross-platform-compatibility/",
          "body": " Cross-Platform Compatibility Atom runs on a number of platforms and while Electron and Node take care of many of the details there are still some considerations to ensure your package works on other operating systems.  Symlinks File symlinks can be used on Windows by non-Administrators by specifying 'junction' as the type (this argument is ignored on macOS &amp; Linux). Also consider:   Symlinks committed to Git will not checkout correctly on Windows - dynamically create what you need with fs.symlink instead   Symlinked directories are only available to Administrators on Windows - avoid a dependency on them    Filenames   Reserved filenames on Windows are com1-com9, lpt1-lpt9, con, nul, aux and prn (regardless of extension, e.g. prn.txt is disallowed)  Reserved characters on Windows are ? \\ / &lt; &gt; ? % | : \" so avoid where possible   Names with spaces when passed to the command line;  Windows requires you surround the path with double quotes e.g. \"c:\\my test\"  macOS and Linux require a backslash before each space e.g. /my\\ test      File paths  Windows uses \\ although some tools and PowerShell allow / too macOS and Linux use /   You can dynamically find out what your platform uses with path.sep or better yet use the node path library functions such as join and normalize which automatically take care of this. Windows supports up to 250 characters for a path - avoid deeply nested directory structures  Paths are not URLs URL parsing routines should not be used on file paths. While they initially look like a relative path it will fail in a number of scenarios on all platforms.  Various characters are misinterpreted, e.g. ? as query string, # as a fragment identifier  Windows drive specifiers are incorrectly parsed as a protocol  If you need to use a path for a URL use the file: protocol with an absolute path instead to ensure drive letters and slashes are appropriately addressed, e.g. file:///c|/test/pic.png  fs.stat on directories The fs.stat function does not return the size of the contents of a directory but rather the allocation size of the directory itself. This returns 0 on Windows and 1024 on macOS and so should not be relied upon.  path.relative can't traverse drives  On a macOS or Linux system path.relative can be used to calculate a relative path to traverse between any two given paths. On Windows this is not always possible as it can contain multiple absolute roots, e.g. c:\\ and d:\\    Rapid file operations Creation and deletion operations may take a few milliseconds to complete. If you need to remove many files and folders consider RimRAF which has built-in retry logic for this.  Line endings  Windows uses CRLF  macOS and Linux use LF  Git on Windows often has autocrlf set which automatically converts between the two  If you are writing specs that use text file fixtures consider that this will interfere with file lengths, hash codes and direct text comparisons. It will also change the Atom selection length by 1 character per line. If you have spec fixtures that are text files you may want to tell Git to force LF, CRLF or not convert them by specifying the paths in .gitattributes e.g. spec/fixtures/always-crlf.txt eol=crlf spec/fixtures/always-lf.txt eol=lf spec/fixtures/leave-as-is.txt -text ",
          "excerpt": " Cross-Platform Compatibility Atom runs on a number of platforms and while Electron and Node take care of many of the details there are still…"
        },
      
    
      
        
        {
          "title": "The Init File",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/the-init-file/",
          "body": " The Init File When Atom finishes loading, it will evaluate init.coffee in your ~/.atom%USERPROFILE%\\.atom directory, giving you a chance to run CoffeeScript code to make customizations. Code in this file has full access to Atom's API. If customizations become extensive, consider creating a package, which we will cover in Package: Word Count. You can open the init.coffee file in an editor from the Atom &gt; Init ScriptFile &gt; Init ScriptEdit &gt; Init Script menu. This file can also be named init.js and contain JavaScript code. For example, if you have the Audio Beep configuration setting enabled, you could add the following code to your init.coffee file to have Atom greet you with an audio beep every time it loads: atom.beep()  Because init.coffee provides access to Atom's API, you can use it to implement useful commands without creating a new package or extending an existing one. Here's a command which uses the Selection API and Clipboard API to construct a Markdown link from the selected text and the clipboard contents as the URL: atom.commands.add 'atom-text-editor', 'markdown:paste-as-link', -&gt; return unless editor = atom.workspace.getActiveTextEditor() selection = editor.getLastSelection() clipboardText = atom.clipboard.read() selection.insertText(\"[#{selection.getText()}](#{clipboardText})\")  Now, reload Atom and use the Command Palette to execute the new command, \"Markdown: Paste As Link\", by name. And if you'd like to trigger the command via a keyboard shortcut, you can define a keybinding for the command.",
          "excerpt": " The Init File When Atom finishes loading, it will evaluate init.coffee in your ~/.atom%USERPROFILE%\\.atom directory, giving you a chance to…"
        },
      
    
      
        
        {
          "title": "Hacking on Atom Core",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/hacking-on-atom-core/",
          "body": " Hacking on Atom Core If you're hitting a bug in Atom or just want to experiment with adding a feature to the core of the system, you'll want to run Atom in Dev Mode with access to a local copy of the Atom source.  Fork the atom/atom repository Follow the GitHub Help instructions on how to fork a repo.  Cloning and bootstrapping Once you've set up your fork of the atom/atom repository, you can clone it to your local machine:  git clone git@github.com:your-username/atom.git  From there, you can navigate into the directory where you've cloned the Atom source code and run the bootstrap script to install all the required dependencies:  cd where-you-cloned-atom script/bootstrap   Running in Development Mode Once you have a local copy of Atom cloned and bootstrapped, you can then run Atom in Development Mode. But first, you have to set the ATOM_DEV_RESOURCE_PATH environment variable. It defaults to ~/github/atom%USERPROFILE%\\github\\atom which then expects the atom/atom repository to be cloned into $ATOM_DEV_RESOURCE_PATH%ATOM_DEV_RESOURCE_PATH%. To run Atom in Dev Mode, use the --dev parameter from the terminal:  atom --dev path-to-open  There are a couple benefits of running Atom in Dev Mode:  When the ATOM_DEV_RESOURCE_PATH environment variable is set correctly, Atom is run using the source code from your local atom/atom repository. This means that you don't have to run script/buildscript\\build every time you change code. Just restart Atom 👍 Packages that exist in ~/.atom/dev/packages%USERPROFILE%\\.atom\\dev\\packages are loaded instead of packages of the same name normally loaded from other locations. This means that you can have development versions of packages you use loaded but easily go back to the stable versions by launching without Dev Mode.   Running Atom Core Tests Locally In order to run Atom Core tests from the terminal, first be certain to set the ATOM_DEV_RESOURCE_PATH environment variable as mentioned above and then:  cd path-to-your-local-atom-repo atom --test spec   Building In order to build Atom from source, you need to have a number of other requirements and take additional steps.   Requirements  macOS 10.9 or later Node.js 6.x or later (we recommend installing it via nvm) npm 3.10.x or later (run npm install -g npm) Command Line Tools for Xcode (run xcode-select --install to install)     Node.js 6.9.4 or later (the architecture of node available to the build system will determine whether you build 32-bit or 64-bit Atom) Python v2.7.x  The python.exe must be available at %SystemDrive%\\Python27\\python.exe. If it is installed elsewhere create a symbolic link to the directory containing the python.exe using: mklink /d %SystemDrive%\\Python27 D:\\elsewhere\\Python27    7zip (7z.exe available from the command line) - for creating distribution zip files  C++ build tools, either:  Visual C++ Build Tools 2015  Visual Studio 2013 Update 5 (Express Edition or better)  Visual Studio 2015 (Community Edition or better)  Unsupported but more convenient for some who know Node: windows-build-tools   Also ensure that:  The default installation folder is chosen so the build tools can find it If using Visual Studio make sure Visual C++ support is selected/installed If using Visual C++ Build Tools make sure Windows 8 SDK is selected/installed A git command is in your path Set the GYP_MSVS_VERSION environment variable to the Visual Studio/Build Tools version (2013 or 2015) e.g. [Environment]::SetEnvironmentVariable(\"GYP_MSVS_VERSION\", \"2015\", \"User\") in PowerShell (or set it in Windows advanced system settings).      Ubuntu LTS 12.04 64-bit is the recommended platform.  Requirements  OS with 64-bit or 32-bit architecture C++11 toolchain Git Node.js 6.x or later (we recommend installing it via nvm) npm 3.10.x or later (run npm install -g npm) Ensure node-gyp uses python2 (run npm config set python /usr/bin/python2 -g, use sudo if you didn't install node via nvm) Development headers for libsecret.  For more details, scroll down to find how to setup a specific Linux distro.  Ubuntu / Debian   Install GNOME headers and other basic prerequisites:  sudo apt-get install build-essential git libsecret-1-dev fakeroot rpm libx11-dev libxkbfile-dev    If script/build exits with an error, you may need to install a newer C++ compiler with C++11:  sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt-get install gcc-5 g++-5 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 80 --slave /usr/bin/g++ g++ /usr/bin/g++-5 sudo update-alternatives --config gcc # choose gcc-5 from the list     Fedora 22+  sudo dnf --assumeyes install make gcc gcc-c++ glibc-devel git-core libsecret-devel rpmdevtools libX11-devel libxkbfile-devel   Fedora 21 / CentOS / RHEL  sudo yum install -y make gcc gcc-c++ glibc-devel git-core libsecret-devel rpmdevtools   Arch  sudo pacman -S --needed gconf base-devel git nodejs npm libsecret python2 libx11 libxkbfile  Be certain to use export PYTHON=/usr/bin/python2 before building Atom.  Slackware  sbopkg -k -i node -i atom   openSUSE  sudo zypper install nodejs nodejs-devel make gcc gcc-c++ glibc-devel git-core libsecret-devel rpmdevtools libX11-devel libxkbfile-devel    Instructions  script/build   To also install the newly built application, use script/build --install.   To also install the newly built application, use script\\build --create-windows-installer and launch one of the generated installers.   To also install the newly built application, use the --create-debian-package or --create-rpm-package option and then install the generated package via the system package manager.   script/build Options    --code-sign: signs the application with the GitHub certificate specified in $ATOM_MAC_CODE_SIGNING_CERT_DOWNLOAD_URL.  --compress-artifacts: zips the generated application as out/atom-mac.zip.  --install[=dir]: installs the application at ${dir}/Atom.app for dev and stable versions or at ${dir}/Atom-Beta.app for beta versions; ${dir} defaults to /Applications.      --code-sign: signs the application with the GitHub certificate specified in $WIN_P12KEY_URL.  --compress-artifacts: zips the generated application as out\\atom-windows.zip (requires 7-Zip).  --create-windows-installer: creates an .exe and two .nupkg packages in the out directory.  --install[=dir]: installs the application in ${dir}\\Atom\\app-dev; ${dir} defaults to %LOCALAPPDATA%.      --compress-artifacts: zips the generated application as out/atom-{arch}.tar.gz.  --create-debian-package: creates a .deb package as out/atom-{arch}.deb   --create-rpm-package: creates a .rpm package as out/atom-{arch}.rpm   --install[=dir]: installs the application in ${dir}; ${dir} defaults to /usr/local.    Troubleshooting  Use this search to get a list of reports about build errors on macOS.    Common Errors   node is not recognized  If you just installed Node.js, you'll need to restart Command Prompt before the node command is available on your path.    msbuild.exe failed with exit code: 1  If using Visual Studio, ensure you have the Visual C++ component installed. Go into Add/Remove Programs, select Visual Studio, press Modify, and then check the Visual C++ box. If using Visual C++ Build Tools, ensure you have the Windows 8 SDK component installed. Go into Add/Remove Programs, select Visual C++ Build Tools, press Modify and then check the Windows 8 SDK box.    script\\build stops with no error or warning shortly after displaying the versions of node, npm and Python  Make sure that the path where you have checked out Atom does not include a space. For example, use C:\\atom instead of C:\\my stuff\\atom. Try moving the repository to C:\\atom. Most likely, the path is too long. See issue #2200.    error MSB4025: The project file could not be loaded. Invalid character in the given encoding.  This can occur because your home directory (%USERPROFILE%) has non-ASCII characters in it. This is a bug in gyp which is used to build native Node.js modules and there is no known workaround.  https://github.com/TooTallNate/node-gyp/issues/297 https://code.google.com/p/gyp/issues/detail?id=393      'node_modules\\.bin\\npm' is not recognized as an internal or external command, operable program or batch file.  This occurs if the previous build left things in a bad state. Run script\\clean and then script\\build again.    script\\build stops at installing runas with Failed at the runas@x.y.z install script.  See the next item.    error MSB8020: The build tools for Visual Studio 201? (Platform Toolset = 'v1?0') cannot be found.  Try setting the GYP_MSVS_VERSION environment variable to 2013 or 2015 depending on what version of Visual Studio/Build Tools is installed and then script\\clean followed by script\\build (re-open the Command Prompt if you set the variable using the GUI).    'node-gyp' is not recognized as an internal or external command, operable program or batch file.  Try running npm install -g node-gyp, and run script\\build again.    Other node-gyp errors on first build attempt, even though the right Node.js and Python versions are installed.  Do try the build command one more time as experience shows it often works on second try in many cases.     Windows build error reports  If all else fails, use this search to get a list of reports about build errors on Windows, and see if yours has already been reported. If it hasn't, please open a new issue with your Windows version, architecture (x86 or x64), and a text dump of your build output, including the Node.js and Python versions.     TypeError: Unable to watch path If you get following error with a big traceback right after Atom starts: TypeError: Unable to watch path  you have to increase number of watched files by inotify. For testing if this is the reason for this error you can execute:  sudo sysctl fs.inotify.max_user_watches=32768  then restart Atom. If Atom now works fine, you can make this setting permanent:  echo 32768 | sudo tee -a /proc/sys/fs/inotify/max_user_watches  See also #2082.  /usr/bin/env: node: No such file or directory If you get this notice when attempting to run any script, you either do not have Node.js installed, or node isn't identified as Node.js on your machine. If it's the latter, this might be caused by installing Node.js via the distro package manager and not nvm, so entering sudo ln -s /usr/bin/nodejs /usr/bin/node into your terminal may fix the issue. On some variants (mostly Debian based distros) you can use update-alternatives too:  sudo update-alternatives --install /usr/bin/node node /usr/bin/nodejs 1 --slave /usr/bin/js js /usr/bin/nodejs   AttributeError: 'module' object has no attribute 'script_main' If you get following error with a big traceback while building Atom: sys.exit(gyp.script_main()) AttributeError: 'module' object has no attribute 'script_main' gyp ERR!  you need to uninstall the system version of gyp. On Fedora you would do the following:  sudo yum remove gyp   Linux build error reports Use this search to get a list of reports about build errors on Linux. ",
          "excerpt": " Hacking on Atom Core If you're hitting a bug in Atom or just want to experiment with adding a feature to the core of the system, you'll want…"
        },
      
    
      
        
        {
          "title": "Creating a Theme",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/creating-a-theme/",
          "body": " Creating a Theme Atom's interface is rendered using HTML, and it's styled via Less which is a superset of CSS. Don't worry if you haven't heard of Less before; it's just like CSS, but with a few handy extensions. Atom supports two types of themes: UI and Syntax. UI themes style elements such as the tree view, the tabs, drop-down lists, and the status bar. Syntax themes style the code, gutter and other elements inside the editor view.  Themes can be installed and changed from the Settings View which you can open by selecting the Atom &gt; PreferencesFile &gt; PreferencesEdit &gt; Preferences menu, and clicking the \"Install\" or \"Themes\" tab on the left hand navigation.  Getting Started Themes are pretty straightforward but it's still helpful to be familiar with a few things before starting:  Less is a superset of CSS, but it has some really handy features like variables. If you aren't familiar with its syntax, take a few minutes to familiarize yourself. You may also want to review the concept of a package.json (as covered in Atom package.json). This file is used to help distribute your theme to Atom users. Your theme's package.json must contain a theme key with a value of ui or syntax for Atom to recognize and load it as a theme. You can find existing themes to install or fork in the atom.io themes registry.   Creating a Syntax Theme Let's create your first theme. To get started, press Cmd+Shift+PCtrl+Shift+P and start typing \"Generate Syntax Theme\" to generate a new theme package. Select \"Generate Syntax Theme,\" and you'll be asked for the path where your theme will be created. Let's call ours motif-syntax.  Tip: Syntax themes should end with -syntax and UI themes should end with -ui.  Atom will display a new window, showing the motif-syntax theme, with a default set of folders and files created for us. If you open the Settings View with Cmd+,Ctrl+, and click the \"Themes\" tab on the left, you'll see the \"Motif\" theme listed in the \"Syntax Theme\" drop-down. Select it from the menu to activate it, now when you open an editor you should see your new motif-syntax theme in action. Open up styles/colors.less to change the various color variables which have already been defined. For example, turn @red into #f4c2c1. Then open styles/base.less and modify the various selectors that have already been defined. These selectors style different parts of code in the editor such as comments, strings and the line numbers in the gutter. As an example, let's make the .gutter background-color into @red. Reload Atom by pressing Alt+Cmd+Ctrl+LAlt+Ctrl+R to see the changes you made reflected in your Atom window. Pretty neat!  Tip: You can avoid reloading to see changes you make by opening an Atom window in Dev Mode. To open a Dev Mode Atom window run atom --dev . in the terminal, or use the View &gt; Developer &gt; Open in Dev Mode menu. When you edit your theme, changes will instantly be reflected!   Note: It's advised to not specify a font-family in your syntax theme because it will override the Font Family field in Atom's settings. If you still like to recommend a font that goes well with your theme, we suggest you do so in your README.   Creating a UI Theme To create a UI theme, do the following:  Fork the ui-theme-template  Clone the forked repository to the local filesystem Open a terminal in the forked theme's directory Open your new theme in a Dev Mode Atom window run atom --dev . in the terminal or use the View &gt; Developer &gt; Open in Dev Mode menu Change the name of the theme in the theme's package.json file Name your theme end with a -ui, for example super-white-ui  Run apm link --dev to symlink your repository to ~/.atom/dev/packages  Reload Atom using Alt+Cmd+Ctrl+LAlt+Ctrl+R  Enable the theme via the \"UI Theme\" drop-down in the \"Themes\" tab of the Settings View Make changes! Since you opened the theme in a Dev Mode window, changes will be instantly reflected in the editor without having to reload.   Tip: Because we used apm link --dev in the above instructions, if you break anything you can always close Atom and launch Atom normally to force Atom to the default theme. This allows you to continue working on your theme even if something goes catastrophically wrong.   Theme Variables UI themes must provide a ui-variables.less and Syntax themes a syntax-variables.less file. It contains predefined variables that packages use to make sure the look and feel matches. Here the variables with the default values:  ui-variables.less syntax-variables.less  These default values will be used as a fallback in case a theme doesn't define its own variables.  Use in Packages In any of your package's .less files, you can access the theme variables by importing the ui-variables or syntax-variables file from Atom. Your package should generally only specify structural styling, and these should come from the style guide. Your package shouldn't specify colors, padding sizes, or anything in absolute pixels. You should instead use the theme variables. If you follow this guideline, your package will look good out of the box with any theme! Here's an example .less file that a package can define using theme variables: @import \"ui-variables\"; .my-selector { background-color: @base-background-color; padding: @component-padding; }  @import \"syntax-variables\"; .my-selector { background-color: @syntax-background-color; }   Development workflow There are a few tools to help make theme development faster and easier.  Live Reload Reloading by pressing Alt+Cmd+Ctrl+LAlt+Ctrl+R after you make changes to your theme is less than ideal. Atom supports live updating of styles on Atom windows in Dev Mode. To launch a Dev Mode window:  Open your theme directory in a dev window by selecting the View &gt; Developer &gt; Open in Dev Mode menu item Or launch Atom from the terminal with atom --dev   If you'd like to reload all the styles at any time, you can use the shortcut Alt+Cmd+Ctrl+LAlt+Ctrl+R.  Developer Tools Atom is based on the Chrome browser, and supports Chrome's Developer Tools. You can open them by selecting the View &gt; Developer &gt; Toggle Developer Tools menu, or by using the Alt+Cmd+ICtrl+Shift+I shortcut. The dev tools allow you to inspect elements and take a look at their CSS properties.  Check out Google's extensive tutorial for a short introduction.  Atom Styleguide If you are creating an UI theme, you'll want a way to see how your theme changes affect all the components in the system. The Styleguide is a page that renders every component Atom supports. To open the Styleguide, open the command palette with Cmd+Shift+PCtrl+Shift+P and search for \"styleguide\", or use the shortcut Cmd+Ctrl+Shift+GCtrl+Shift+G.   Side by side Sometimes when creating a theme (or package) things can go wrong and the editor becomes un-usable. E.g. if the text and background have the same color or something gets pushed out of sight. To avoid having to open Atom in \"normal\" mode to fix the issue, it's advised to open two Atom windows. One for making changes and one in Dev Mode to see the changes getting applied.   Make changes on the left, see the changes getting applied in \"Dev Mode\" on the right.  Now if you mess up something, only the window in \"Dev Mode\" will be affected and you can easily correct the mistake in your \"normal\" window.  Publish your theme Once you're happy with your theme and would like to share it with other Atom users, it's time to publish it.  Follow the steps on the Publishing page. The example used is for the Word Count package, but publishing a theme works exactly the same.",
          "excerpt": " Creating a Theme Atom's interface is rendered using HTML, and it's styled via Less which is a superset of CSS. Don't worry if you haven't he…"
        },
      
    
      
        
        {
          "title": "Contributing to Official Atom Packages",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/contributing-to-official-atom-packages/",
          "body": " Contributing to Official Atom Packages If you think you know which package is causing the issue you are reporting, feel free to open up the issue in that specific repository instead. When in doubt just open the issue on the atom/atom repository but be aware that it may get closed and reopened in the proper package's repository.  Hacking on Packages  Cloning The first step is creating your own clone. For some packages, you may also need to install the requirements necessary for building Atom in order to run apm install. For example, if you want to make changes to the tree-view package, fork the repo on your github account, then clone it:  git clone git@github.com:your-username/tree-view.git  Next install all the dependencies:  cd tree-view apm install Installing modules ✓  Now you can link it to development mode so when you run an Atom window with atom --dev, you will use your fork instead of the built in package:  apm link -d   Running in Development Mode Editing a package in Atom is a bit of a circular experience: you're using Atom to modify itself. What happens if you temporarily break something? You don't want the version of Atom you're using to edit to become useless in the process. For this reason, you'll only want to load packages in development mode while you are working on them. You'll perform your editing in stable mode, only switching to development mode to test your changes. To open a development mode window, use the \"Application: Open Dev\" command. You can also run dev mode from the command line with atom --dev. To load your package in development mode, create a symlink to it in ~/.atom/dev/packages. This occurs automatically when you clone the package with apm develop. You can also run apm link --dev and apm unlink --dev from the package directory to create and remove dev-mode symlinks.  Installing Dependencies You'll want to keep dependencies up to date by running apm update after pulling any upstream changes.",
          "excerpt": " Contributing to Official Atom Packages If you think you know which package is causing the issue you are reporting, feel free to open up the …"
        },
      
    
      
        
        {
          "title": "Handling URIs",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/handling-uris/",
          "body": " Handling URIs Beginning in Atom 1.23, packages have the ability to handle special URIs triggered from the system; for example, a package named my-package can register itself to handle any URI starting with atom://my-package/.  Warning: Handling URIs triggered from other applications, like a web browser, is a powerful tool, but also one that can be jarring. You should shape your package's user experience to handle this well. In general, you should avoid taking direct action on behalf of a user. For example, a URI handler that immediately installs a package is too invasive, but a URI handler that shows the package's pane in the settings view is useful. A URI handler that begins to clone a repo is overly aggressive, but a URI handler that prompts the user to clone a repo is okay. Any package with a URI handler that we feel violates this guideline is subject to removal from the Atom package registry at our discretion.   Modifying your package.json  The first step to handling URIs from your package is to modify its package.json file. You should add a new key called uriHandler, and its value should be an object. The uriHandler object must contain a key called method with a string value that tells Atom which method in your package to call when a URI needs to be handled. The object can optionally include a key called deferActivation which can be set to the boolean false to prevent Atom from deferring activation of your package — see more below. For example, if we want our package my-package to handle URIs with a method on our package's main module called handleURI, we could add the following to our package.json: \"uriHandler\": { \"method\": \"handleURI\" }   Modifying your Main Module Now that we've told Atom that we want our package to handle URIs beginning with atom://my-package/ via our handleURI method, we need to actually write this method. Atom passes two arguments to your URI handler method; the first one is the fully-parsed URI plus query string, parsed with Node's url.parse(uri, true). The second argument is the raw, string URI; this is normally not needed since the first argument gives you structured information about the URI. Here's a sample package, written in JavaScript, that handles URIs with the package.json configuration we saw above. export default { activate () { // normal activation code here }, handleURI (parsedUri) { console.log(parsedUri) } }  When Atom handles, for example, the URI atom://my-package/my/test/url?value=42&amp;other=false, the package would log out something like the following: { protocol: 'atom:', slashes: true, auth: null, host: 'my-package', port: null, hostname: 'my-package', hash: null, search: '?value=true&amp;other=false', query: { value: '42', other: 'false' }, pathname: '/my/test/url', path: '/my/test/url?value=true&amp;other=false', href: 'atom://my-package/my/test/url?value=true&amp;other=false' }  Notice that the query string arguments are available in the query property, but are strings — you'll have to convert to other native types yourself.  Controlling Activation Deferral For performance reasons, adding a uriHandler entry to your package's package.json will enable deferred activation. This means that Atom will not activate your package until it has a URI for it to handle — it will then activate your package and then immediately call the URI handler method. If you want to disable the deferred activation, ensuring your package is activated upon startup, you can add \"deferActivation\": false to the URI handler config. For example, \"uriHandler\": { \"method\": \"handleURI\", \"deferActivation\": false }  Before doing this, make sure your package actually needs to be activated immediately — disabling deferred activation means Atom takes longer to start since it has to activate all packages without deferred activation.  Linux Support Because URI handling is different across operating systems and distributions, there is no built-in URI handler support for Atom on Linux. If you want to configure URI handling on your system yourself, then you should configure atom: protocol URI's to trigger atom with the --uri-handler flag; for example, the URI atom://test/uri should launch Atom via atom --uri-handler atom://test/uri.",
          "excerpt": " Handling URIs Beginning in Atom 1.23, packages have the ability to handle special URIs triggered from the system; for example, a package nam…"
        },
      
    
      
        
        {
          "title": "Publishing",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/publishing/",
          "body": " Publishing Atom bundles a command line utility called apm which we first used back in Command Line to search for and install packages via the command line. The apm command can also be used to publish Atom packages to the public registry and update them.  Prepare Your Package There are a few things you should double check before publishing:  Your package.json file has name, description, and repository fields. Your package.json file has a version field with a value of \"0.0.0\". Your package.json file has an engines field that contains an entry for Atom such as: \"engines\": {\"atom\": \"&gt;=1.0.0 &lt;2.0.0\"}. Your package has a README.md file at the root. Your repository URL in the package.json file is the same as the URL of your repository. Your package is in a Git repository that has been pushed to GitHub. Follow this guide if your package isn't already on GitHub.   Publish Your Package Before you publish a package it is a good idea to check ahead of time if a package with the same name has already been published to the atom.io package registry. You can do that by visiting https://atom.io/packages/your-package-name to see if the package already exists. If it does, update your package's name to something that is available before proceeding. Now let's review what the apm publish command does:  Registers the package name on atom.io if it is being published for the first time. Updates the version field in the package.json file and commits it. Creates a new Git tag for the version being published. Pushes the tag and current branch up to GitHub. Updates atom.io with the new version being published.  Now run the following commands to publish your package:  cd path-to-your-package apm publish minor  If this is the first package you are publishing, the apm publish command may prompt you for your GitHub username and password. This is required to publish and you only need to enter this information the first time you publish. The credentials are stored securely in your keychain once you login. Your package is now published and available on atom.io. Head on over to https://atom.io/packages/your-package-name to see your package's page. With apm publish, you can bump the version and publish by using  apm publish version-type  where version-type can be major, minor and patch. The major option to the publish command tells apm to increment the first number of the version before publishing so the published version will be 1.0.0 and the Git tag created will be v1.0.0. The minor option to the publish command tells apm to increment the second number of the version before publishing so the published version will be 0.1.0 and the Git tag created will be v0.1.0. The patch option to the publish command tells apm to increment the third number of the version before publishing so the published version will be 0.0.1 and the Git tag created will be v0.0.1. Use major when you make a change that breaks backwards compatibility, like changing defaults or removing features. Use minor when adding new functionality or options, but without breaking backwards compatibility. Use patch when you've changed the implementation of existing features, but without changing the behaviour or options of your package. Check out semantic versioning to learn more about best practices for versioning your package releases. You can also run apm help publish to see all the available options and apm help to see all the other available commands.",
          "excerpt": " Publishing Atom bundles a command line utility called apm which we first used back in Command Line to search for and install packages via th…"
        },
      
    
      
        
        {
          "title": "Converting from TextMate",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/converting-from-textmate/",
          "body": " Converting from TextMate It's possible that you have themes or grammars from TextMate that you like and use and would like to convert to Atom. If so, you're in luck because there are tools to help with the conversion.  Converting a TextMate Grammar Bundle Converting a TextMate bundle will allow you to use its editor preferences, snippets, and colorization inside Atom. Let's convert the TextMate bundle for the R programming language. You can find other existing TextMate bundles on GitHub. You can convert the R bundle with the following command:  apm init --package language-r --convert https://github.com/textmate/r.tmbundle  You can now change directory into language-r to see the converted bundle. Once you link your package with the apm link command, your new package is ready to use. Launch Atom and open a .r file in the editor to see it in action!  Converting a TextMate Syntax Theme This section will go over how to convert a TextMate theme to an Atom theme.  Differences TextMate themes use plist files while Atom themes use CSS or Less to style the UI and syntax in the editor. The utility that converts the theme first parses the theme's plist file and then creates comparable CSS rules and properties that will style Atom similarly.  Convert the Theme Download the theme you wish to convert, you can browse existing TextMate themes on the TextMate website. Now, let's say you've downloaded the theme to ~/Downloads/MyTheme.tmTheme, you can convert the theme with the following command:  apm init --theme my-theme --convert ~/Downloads/MyTheme.tmTheme  You can then change directory to my-theme to see the converted theme.  Activate the Theme Once your theme is installed you can enable it by launching Atom and opening the Settings View with the Atom &gt; PreferencesFile &gt; PreferencesEdit &gt; Preferences menu item. Then select the \"Themes\" tab on the left side navigation. Finally, choose \"My Theme\" from the \"Syntax Theme\" dropdown menu to enable your new theme. Your theme is now enabled, open an editor to see it in action!",
          "excerpt": " Converting from TextMate It's possible that you have themes or grammars from TextMate that you like and use and would like to convert to Ato…"
        },
      
    
      
        
        {
          "title": "Writing specs",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/writing-specs/",
          "body": " Writing Specs We've looked at and written a few specs through the examples already. Now it's time to take a closer look at the spec framework itself. How exactly do you write tests in Atom? Atom uses Jasmine as its spec framework. Any new functionality should have specs to guard against regressions.  Create a New Spec Atom specs and package specs are added to their respective spec directory. The example below creates a spec for Atom core.  Create a Spec File Spec files must end with -spec so add sample-spec.coffee to the spec directory.  Add One or More describe Methods The describe method takes two arguments, a description and a function. If the description explains a behavior it typically begins with when; if it is more like a unit test it begins with the method name. describe \"when a test is written\", -&gt; # contents  or describe \"Editor::moveUp\", -&gt; # contents   Add One or More it Methods The it method also takes two arguments, a description and a function. Try and make the description flow with the it method. For example, a description of \"this should work\" doesn't read well as \"it this should work\". But a description of \"should work\" sounds great as \"it should work\". describe \"when a test is written\", -&gt; it \"has some expectations that should pass\", -&gt; # Expectations   Add One or More Expectations The best way to learn about expectations is to read the Jasmine documentation about them. Below is a simple example. describe \"when a test is written\", -&gt; it \"has some expectations that should pass\", -&gt; expect(\"apples\").toEqual(\"apples\") expect(\"oranges\").not.toEqual(\"apples\")   Custom Matchers In addition to the Jasmine's built-in matchers, Atom includes the following:  jasmine-jquery The toBeInstanceOf matcher is for the instanceof operator The toHaveLength matcher compares against the .length property The toExistOnDisk matcher checks if the file exists in the filesystem The toHaveFocus matcher checks if the element currently has focus The toShow matcher tests if the element is visible in the dom  These are defined in spec/spec-helper.coffee.  Asynchronous Specs Writing Asynchronous specs can be tricky at first. Some examples.  Promises Working with promises is rather easy in Atom. You can use our waitsForPromise function. describe \"when we open a file\", -&gt; it \"should be opened in an editor\", -&gt; waitsForPromise -&gt; atom.workspace.open('c.coffee').then (editor) -&gt; expect(editor.getPath()).toContain 'c.coffee'  This method can be used in the describe, it, beforeEach and afterEach functions. describe \"when we open a file\", -&gt; beforeEach -&gt; waitsForPromise -&gt; atom.workspace.open 'c.coffee' it \"should be opened in an editor\", -&gt; expect(atom.workspace.getActiveTextEditor().getPath()).toContain 'c.coffee'  If you need to wait for multiple promises use a new waitsForPromise function for each promise. (Caution: Without beforeEach this example will fail!) describe \"waiting for the packages to load\", -&gt; beforeEach -&gt; waitsForPromise -&gt; atom.workspace.open('sample.js') waitsForPromise -&gt; atom.packages.activatePackage('tabs') waitsForPromise -&gt; atom.packages.activatePackage('tree-view') it 'should have waited long enough', -&gt; expect(atom.packages.isPackageActive('tabs')).toBe true expect(atom.packages.isPackageActive('tree-view')).toBe true  waitsForPromise can take an additional object argument before the function. The object can have the following properties:   shouldReject Whether the promise should reject or resolve (default: false)  timeout The amount of time (in ms) to wait for the promise to be resolved or rejected (default: process.env.CI ? 60000 : 5000)  label The label to display if promise times out (default: 'promise to be resolved or rejected')  describe \"when we open a file\", -&gt; it \"should be opened in an editor\", -&gt; waitsForPromise { shouldReject: false, timeout: 5000, label: 'promise to be resolved or rejected' }, -&gt; atom.workspace.open('c.coffee').then (editor) -&gt; expect(editor.getPath()).toContain 'c.coffee'   Asynchronous Functions with Callbacks Specs for asynchronous functions can be done using the waitsFor and runs functions. A simple example. describe \"fs.readdir(path, cb)\", -&gt; it \"is async\", -&gt; spy = jasmine.createSpy('fs.readdirSpy') fs.readdir('/tmp/example', spy) waitsFor -&gt; spy.callCount &gt; 0 runs -&gt; exp = [null, ['example.coffee']] expect(spy.mostRecentCall.args).toEqual exp expect(spy).toHaveBeenCalledWith(null, ['example.coffee'])  For a more detailed documentation on asynchronous tests please visit the Jasmine documentation.  Running Specs Most of the time you'll want to run specs by triggering the window:run-package-specs command. This command is not only to run package specs, it can also be used to run Atom core specs when working on Atom itself. This will run all the specs in the current project's spec directory. To run a limited subset of specs use the fdescribe or fit methods. You can use those to focus a single spec or several specs. Modified from the example above, focusing an individual spec looks like this: describe \"when a test is written\", -&gt; fit \"has some expectations that should pass\", -&gt; expect(\"apples\").toEqual(\"apples\") expect(\"oranges\").not.toEqual(\"apples\")   Running on CI It is now easy to run the specs in a CI environment like Travis and AppVeyor. See the Travis CI For Your Packages and AppVeyor CI For Your Packages posts for more details.  Running via the Command Line To run tests on the command line, run Atom with the --test flag followed by one or more paths to test files or directories. You can also specify a --timeout option, which will force-terminate your tests after a certain number of seconds have passed.  atom --test --timeout 60 ./test/test-1.js ./test/test-2.js   Customizing your test runner  Warning: This API is available as of 1.2.0-beta0, and it is experimental and subject to change. Test runner authors should be prepared to test their code against future beta releases until it stabilizes.  By default, package tests are run with Jasmine 1.3, which is outdated but can't be changed for compatibility reasons. You can specify your own custom test runner by including an atomTestRunner field in your package.json. Atom will require whatever module you specify in this field, so you can use a relative path or the name of a module in your package's dependencies. Your test runner module must export a single function, which Atom will call within a new window to run your package's tests. Your function will be called with the following parameters:   testPaths An array of paths to tests to run. Could be paths to files or directories.  buildAtomEnvironment A function that can be called to construct an instance of the atom global. No atom global will be explicitly assigned, but you can assign one in your runner if desired. This function should be called with the following parameters:   applicationDelegate An object responsible for Atom's interaction with the browser process and host OS. Use buildDefaultApplicationDelegate for a default instance. You can override specific methods on this object to prevent or test these interactions.  window A window global.  document A document global.  configDirPath A path to the configuration directory (usually ~/.atom).  enablePersistence A boolean indicating whether the Atom environment should save or load state from the file system. You probably want this to be false.    buildDefaultApplicationDelegate A function that builds a default instance of the application delegate, suitable to be passed as the applicationDelegate parameter to buildAtomEnvironment.  logFile An optional path to a log file to which test output should be logged.  headless A boolean indicating whether or not the tests are being run from the command line via atom --test.  legacyTestRunner This function can be invoked to run the legacy Jasmine runner, giving your package a chance to transition to a new test runner while maintaining a subset of its tests in the old environment.  Your function should return a promise that resolves to an exit code when your tests are finish running. This exit code will be returned when running your tests via the command line.",
          "excerpt": " Writing Specs We've looked at and written a few specs through the examples already. Now it's time to take a closer look at the spec framewor…"
        },
      
    
      
        
        {
          "title": "Package: Modifying Text",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/package-modifying-text/",
          "body": " Package: Modifying Text Now that we have our first package written, let's go through examples of other types of packages we can make. This section will guide you though creating a simple command that replaces the selected text with ascii art. When you run our new command with the word \"cool\" selected, it will be replaced with:  o888 ooooooo ooooooo ooooooo 888 888 888 888 888 888 888 888 888 888 888 888 888 888 88ooo888 88ooo88 88ooo88 o888o  This should demonstrate how to do basic text manipulation in the current text buffer and how to deal with selections. The final package can be viewed at https://github.com/atom/ascii-art.  Basic Text Insertion To begin, press Cmd+Shift+PCtrl+Shift+P to bring up the Command Palette. Type \"generate package\" and select the \"Package Generator: Generate Package\" command, just as we did in the section on package generation. Enter ascii-art as the name of the package. Now let's edit the package files to make our ASCII Art package do something interesting. Since this package doesn't need any UI, we can remove all view-related code so go ahead and delete lib/ascii-art-view.js, spec/ascii-art-view-spec.js, and styles/. Next, open up lib/ascii-art.js and remove all view code, so it looks like this: const {CompositeDisposable} = require('atom') module.exports = { subscriptions: null, activate () { this.subscriptions = new CompositeDisposable() this.subscriptions.add(atom.commands.add('atom-workspace', {'ascii-art:convert': () =&gt; this.convert()}) ) }, deactivate () { this.subscriptions.dispose() }, convert() { console.log('Convert text!') } }   Create a Command Now let's add a command. You should namespace your commands with the package name followed by a : and then the name of the command. As you can see in the code, we called our command ascii-art:convert and we will define it to call the convert() method when it's executed. So far, that will simply log to the console. Let's start by making it insert something into the text buffer. convert() { const editor = atom.workspace.getActiveTextEditor() if (editor) { editor.insertText('Hello, World!') } }  As in Counting Words, we're using atom.workspace.getActiveTextEditor() to get the object that represents the active text editor. If this convert() method is called when not focused on a text editor, nothing will happen. Next we insert a string into the current text editor with the insertText() method. This will insert the text wherever the cursor currently is in the current editor. If there are selections, it will replace all selections with the \"Hello, World!\" text.  Reload the Package Before we can trigger ascii-art:convert, we need to load the latest code for our package by reloading the window. Run the command \"Window: Reload\" from the Command Palette or by pressing Alt+Cmd+Ctrl+LCtrl+Shift+F5.  Trigger the Command Now open the Command Palette and search for the \"Ascii Art: Convert\" command. But it's not there! To fix this, open package.json and find the property called activationCommands. Activation commands make Atom launch faster by allowing Atom to delay a package's activation until it's needed. So remove the existing command and use ascii-art:convert in activationCommands: \"activationCommands\": { \"atom-workspace\": \"ascii-art:convert\" }  First, reload the window by running the command \"Window: Reload\" from the command palette. Now when you run the \"Ascii Art: Convert\" command it will insert \"Hello, World!\" into the active editor, if any.  Add a Key Binding Now let's add a key binding to trigger the ascii-art:convert command. Open keymaps/ascii-art.json and add a key binding linking Alt+Ctrl+A to the ascii-art:convert command. You can delete the pre-existing key binding since you won't need it anymore. When finished, the file should look like this: { \"atom-text-editor\": { \"ctrl-alt-a\": \"ascii-art:convert\" } }  Now reload the window and verify that the key binding works.  Warning: The Atom keymap system is case-sensitive. This means that there is a distinction between a and A when creating keybindings. a means that you want to trigger the keybinding when you press A. But A means that you want to trigger the keybinding when you press Shift+A. You can also write shift-a when you want to trigger the keybinding when you press Shift+A. We strongly recommend always using lowercase and explicitly spelling out when you want to include Shift in your keybindings.   Add the ASCII Art Now we need to convert the selected text to ASCII art. To do this we will use the figlet Node module from npm. Open package.json and add the latest version of figlet to the dependencies: \"dependencies\": { \"figlet\": \"1.0.8\" }  After saving the file, run the command \"Update Package Dependencies: Update\" from the Command Palette. This will install the package's node module dependencies, only figlet in this case. You will need to run \"Update Package Dependencies: Update\" whenever you update the dependencies field in your package.json file. If for some reason this doesn't work, you'll see a message saying \"Failed to update package dependencies\" and you will find a new npm-debug.log file in your directory. That file should give you some idea as to what went wrong. Now require the figlet node module in lib/ascii-art.js and instead of inserting \"Hello, World!\", convert the selected text to ASCII art. convert () { const editor = atom.workspace.getActiveTextEditor() if (editor) { const selection = editor.getSelectedText() const figlet = require('figlet') const font = 'o8' figlet(selection, {font}, function (error, art) { if (error) { console.error(error) } else { editor.insertText(`\\n${art}\\n`) } }) } }  Now reload the editor, select some text in an editor window and press Alt+Ctrl+A. It should be replaced with a ridiculous ASCII art version instead. There are a couple of new things in this example we should look at quickly. The first is the editor.getSelectedText() which, as you might guess, returns the text that is currently selected. We then call the Figlet code to convert that into something else and replace the current selection with it with the editor.insertText() call.  Summary In this section, we've made a UI-less package that takes selected text and replaces it with a processed version. This could be helpful in creating linters or checkers for your code.",
          "excerpt": " Package: Modifying Text Now that we have our first package written, let's go through examples of other types of packages we can make. This s…"
        },
      
    
      
        
        {
          "title": "Package: Word Count",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/package-word-count/",
          "body": " Package: Word Count Let's get started by writing a very simple package and looking at some of the tools needed to develop one effectively. We'll start by writing a package that tells you how many words are in the current buffer and display it in a small modal window.  Package Generator The simplest way to start a package is to use the built-in package generator that ships with Atom. As you might expect by now, this generator is itself a separate package implemented in package-generator. You can run the generator by invoking the command palette and searching for \"Generate Package\". A dialog will appear asking you to name your new project. Name it your-name-word-count. Atom will then create that directory and fill it out with a skeleton project and link it into your ~/.atom/packages%USERPROFILE%\\.atom\\packages directory so it's loaded when you launch your editor next time.  Note: You may encounter a situation where your package is not loaded. That is because a new package using the same name as an actual package hosted on atom.io (e.g. \"wordcount\" and \"word-count\") is not being loaded as you expected. If you follow our suggestion above of using the your-name-word-count package name, you should be safe    You can see that Atom has created about a dozen files that make up the package. Let's take a look at each of them to get an idea of how a package is structured, then we can modify them to get our word count functionality. The basic package layout is as follows: my-package/ ├─ grammars/ ├─ keymaps/ ├─ lib/ ├─ menus/ ├─ spec/ ├─ snippets/ ├─ styles/ ├─ index.js └─ package.json  Not every package will have (or need) all of these directories and the package generator doesn't create snippets or grammars. Let's see what some of these are so we can start messing with them.  package.json  Similar to Node modules, Atom packages contain a package.json file in their top-level directory. This file contains metadata about the package, such as the path to its \"main\" module, library dependencies, and manifests specifying the order in which its resources should be loaded. In addition to some of the regular Node package.json keys available, Atom package.json files have their own additions.   main: the path to the JavaScript file that's the entry point to your package. If this is missing, Atom will default to looking for an index.coffee or index.js.  styles: an Array of Strings identifying the order of the style sheets your package needs to load. If not specified, style sheets in the styles directory are added alphabetically.  keymaps: an Array of Strings identifying the order of the key mappings your package needs to load. If not specified, mappings in the keymaps directory are added alphabetically.  menus: an Array of Strings identifying the order of the menu mappings your package needs to load. If not specified, mappings in the menus directory are added alphabetically.  snippets: an Array of Strings identifying the order of the snippets your package needs to load. If not specified, snippets in the snippets directory are added alphabetically.  activationCommands: an Object identifying commands that trigger your package's activation. The keys are CSS selectors, the values are Arrays of Strings identifying the command. The loading of your package is delayed until one of these events is triggered within the associated scope defined by the CSS selector. If not specified, the activate() method of your main export will be called when your package is loaded.  activationHooks: an Array of Strings identifying hooks that trigger your package's activation. The loading of your package is delayed until one of these hooks are triggered. Currently, there are two activation hooks: language-package-name:grammar-used (e.g., language-javascript:grammar-used) and core:loaded-shell-environment.  The package.json in the package we've just generated looks like this currently: { \"name\": \"wordcount\", \"main\": \"./lib/wordcount\", \"version\": \"0.0.0\", \"description\": \"A short description of your package\", \"activationCommands\": { \"atom-workspace\": \"wordcount:toggle\" }, \"repository\": \"https://github.com/atom/your-name-word-count\", \"license\": \"MIT\", \"engines\": { \"atom\": \"&gt;=1.0.0 &lt;2.0.0\" }, \"dependencies\": { } }  If you wanted to use activationHooks, you might have: { \"name\": \"wordcount\", \"main\": \"./lib/wordcount\", \"version\": \"0.0.0\", \"description\": \"A short description of your package\", \"activationHooks\": [\"language-javascript:grammar-used\", \"language-coffee-script:grammar-used\"], \"repository\": \"https://github.com/atom/your-name-word-count\", \"license\": \"MIT\", \"engines\": { \"atom\": \"&gt;=1.0.0 &lt;2.0.0\" }, \"dependencies\": { } }  One of the first things you should do is ensure that this information is filled out. The name, description, repository URL the project will be at, and the license can all be filled out immediately. The other information we'll get into more detail on as we go.  Warning: Do not forget to update the repository URL. The one generated for you is invalid by design and will prevent you from publishing your package until updated.   Source Code If you want to extend Atom's behavior, your package should contain a single top-level module, which you export from whichever file is indicated by the main key in your package.json file. In the package we just generated, the main package file is lib/wordcount.js. The remainder of your code should be placed in the lib directory, and required from your top-level file. If the main key is not in your package.json file, it will look for index.js or index.coffee as the main entry point. Your package's top-level module is a singleton object that manages the lifecycle of your extensions to Atom. Even if your package creates ten different views and appends them to different parts of the DOM, it's all managed from your top-level object. Your package's top-level module can implement the following basic methods:   activate(state): This optional method is called when your package is activated. It is passed the state data from the last time the window was serialized if your module implements the serialize() method. Use this to do initialization work when your package is started (like setting up DOM elements or binding events).  initialize(state): (Available in Atom 1.14 and above) This optional method is similar to activate() but is called earlier. Whereas activation occurs after the workspace has been deserialized (and can therefore happen after your package's deserializers have been called), initialize() is guaranteed to be called before everything. Use activate() if you want to be sure that the workspace is ready; use initialize() if you need to do some setup prior to your deserializers or view providers being invoked.  serialize(): This optional method is called when the window is shutting down, allowing you to return JSON to represent the state of your component. When the window is later restored, the data you returned is passed to your module's activate method so you can restore your view to where the user left off.  deactivate(): This optional method is called when the window is shutting down. If your package is watching any files or holding external resources in any other way, release them here. If you're just subscribing to things on window, you don't need to worry because that's getting torn down anyway.   Style Sheets Style sheets for your package should be placed in the styles directory. Any style sheets in this directory will be loaded and attached to the DOM when your package is activated. Style sheets can be written as CSS or Less, but Less is recommended. Ideally, you won't need much in the way of styling. Atom provides a standard set of components which define both the colors and UI elements for any package that fits into Atom seamlessly. You can view all of Atom's UI components by opening the styleguide: open the command palette Cmd+Shift+PCtrl+Shift+P and search for styleguide, or type Cmd+Ctrl+Shift+GCtrl+Shift+G. If you do need special styling, try to keep only structural styles in the package style sheets. If you must specify colors and sizing, these should be taken from the active theme's ui-variables.less. An optional styleSheets array in your package.json can list the style sheets by name to specify a loading order; otherwise, style sheets are loaded alphabetically.  Keymaps You can provide key bindings for commonly used actions for your extension, especially if you're also adding a new command. In our new package, we have a keymap filled in for us already in the keymaps/wordcount.json file: { \"atom-workspace\": { \"ctrl-alt-o\": \"your-name-word-count:toggle\" } }  This means that if you press Alt+Ctrl+O, our package will run the your-name-word-count:toggle command. We'll look at that code next, but if you want to change the default key mapping, you can do that in this file. Keymaps are placed in the keymaps subdirectory. By default, all keymaps are loaded in alphabetical order. An optional keymaps array in your package.json can specify which keymaps to load and in what order. Keybindings are executed by determining which element the keypress occurred on. In the example above, the your-name-word-count:toggle command is executed when pressing Alt+Ctrl+O on the atom-workspace element. Because the atom-workspace element is the parent of the entire Atom UI, this means the key combination will work anywhere in the application. We'll cover more advanced keybinding stuff a bit later in Keymaps in Depth.  Menus Menus are placed in the menus subdirectory. This defines menu elements like what pops up when you right click a context-menu or would go in the application menu to trigger functionality in your plugin. By default, all menus are loaded in alphabetical order. An optional menus array in your package.json can specify which menus to load and in what order.  Application Menu It's recommended that you create an application menu item under the Packages menu for common actions with your package that aren't tied to a specific element. If we look in the menus/your-name-word-count.json file that was generated for us, we'll see a section that looks like this:  \"menu\": [ { \"label\": \"Packages\", \"submenu\": [ { \"label\": \"Word Count\", \"submenu\": [ { \"label\": \"Toggle\", \"command\": \"your-name-word-count:toggle\" } ] } ] } ]  This section puts a \"Toggle\" menu item under a menu group named \"Your Name Word Count\" in the \"Packages\" menu.  When you select that menu item, it will run the your-name-word-count:toggle command, which we'll look at in a bit. The menu templates you specify are merged with all other templates provided by other packages in the order which they were loaded.  Context Menu It's recommended to specify a context menu item for commands that are linked to specific parts of the interface. In our menus/your-name-word-count.json file, we can see an auto-generated section that looks like this: \"context-menu\": { \"atom-text-editor\": [ { \"label\": \"Toggle your-name-word-count\", \"command\": \"your-name-word-count:toggle\" } ] }  This adds a \"Toggle Word Count\" menu option to the menu that pops up when you right-click in an Atom text editor pane.  When you click that it will again run the your-name-word-count:toggle method in your code. Context menus are created by determining which element was selected and then adding all of the menu items whose selectors match that element (in the order which they were loaded). The process is then repeated for the elements until reaching the top of the DOM tree. You can also add separators and submenus to your context menus. To add a submenu, provide a submenu key instead of a command. To add a separator, add an item with a single type: 'separator' key/value pair. For instance, you could do something like this: { \"context-menu\": { \"atom-workspace\": [ { \"label\": \"Text\", \"submenu\": [ { \"label\": \"Inspect Element\", \"command\": \"core:inspect\" }, { \"type\": \"separator\" }, { \"label\": \"Selector All\", \"command\": \"core:select-all\" }, { \"type\": \"separator\" }, { \"label\": \"Deleted Selected Text\", \"command\": \"core:delete\" } ] } ] } }   Developing Our Package Currently with the generated package we have, if we run that your-name-word-count:toggle command through the menu or the command palette, we'll get a dialog that says \"The Wordcount package is Alive! It's ALIVE!\".   Understanding the Generated Code Let's take a look at the code in our lib directory and see what is happening. There are two files in our lib directory. One is the main file (lib/your-name-word-count.js), which is pointed to in the package.json file as the main file to execute for this package. This file handles the logic of the whole plugin. The second file is a View class, lib/your-name-word-count-view.js, which handles the UI elements of the package. Let's look at this file first, since it's pretty simple. export default class YourNameWordCountView { constructor(serializedState) { // Create root element this.element = document.createElement('div'); this.element.classList.add('your-name-word-count'); // Create message element const message = document.createElement('div'); message.textContent = 'The YourNameWordCount package is Alive! It\\'s ALIVE!'; message.classList.add('message'); this.element.appendChild(message); } // Returns an object that can be retrieved when package is activated serialize() {} // Tear down any state and detach destroy() { this.element.remove(); } getElement() { return this.element; } }  Basically the only thing happening here is that when the View class is created, it creates a simple div element and adds the your-name-word-count class to it (so we can find or style it later) and then adds the \"Your Name Word Count package is Alive!\" text to it. There is also a getElement method which returns that div. The serialize and destroy methods don't do anything and we won't have to worry about that until another example. Notice that we're simply using the basic browser DOM methods: createElement() and appendChild(). The second file we have is the main entry point to the package. Again, because it's referenced in the package.json file. Let's take a look at that file. import YourNameWordCountView from './your-name-word-count-view'; import { CompositeDisposable } from 'atom'; export default { yourNameWordCountView: null, modalPanel: null, subscriptions: null, activate(state) { this.yourNameWordCountView = new YourNameWordCountView(state.yourNameWordCountViewState); this.modalPanel = atom.workspace.addModalPanel({ item: this.yourNameWordCountView.getElement(), visible: false }); // Events subscribed to in atom's system can be easily cleaned up with a CompositeDisposable this.subscriptions = new CompositeDisposable(); // Register command that toggles this view this.subscriptions.add(atom.commands.add('atom-workspace', { 'your-name-word-count:toggle': () =&gt; this.toggle() })); }, deactivate() { this.modalPanel.destroy(); this.subscriptions.dispose(); this.yourNameWordCountView.destroy(); }, serialize() { return { yourNameWordCountViewState: this.yourNameWordCountView.serialize() }; }, toggle() { console.log('YourNameWordCount was toggled!'); return ( this.modalPanel.isVisible() ? this.modalPanel.hide() : this.modalPanel.show() ); } };  There is a bit more going on here. First of all we can see that we are defining four methods. The only required one is activate. The deactivate and serialize methods are expected by Atom but optional. The toggle method is one Atom is not looking for, so we'll have to invoke it somewhere for it to be called, which you may recall we do both in the activationCommands section of the package.json file and in the action we have in the menu file. The deactivate method simply destroys the various class instances we've created and the serialize method simply passes on the serialization to the View class. Nothing too exciting here. The activate command does a number of things. For one, it is not called automatically when Atom starts up, it is first called when one of the activationCommands as defined in the package.json file are called. In this case, activate is only called the first time the toggle command is called. If nobody ever invokes the menu item or hotkey, this code is never called. This method does two things. The first is that it creates an instance of the View class we have and adds the element that it creates to a hidden modal panel in the Atom workspace. this.yourNameWordCountView = new YourNameWordCountView(state.yourNameWordCountViewState); this.modalPanel = atom.workspace.addModalPanel({ item: this.yourNameWordCountView.getElement(), visible: false });  We'll ignore the state stuff for now, since it's not important for this simple plugin. The rest should be fairly straightforward. The next thing this method does is create an instance of the CompositeDisposable class so it can register all the commands that can be called from the plugin so other plugins could subscribe to these events. // Events subscribed to in atom's system can be easily cleaned up with a CompositeDisposable this.subscriptions = new CompositeDisposable(); // Register command that toggles this view this.subscriptions.add(atom.commands.add('atom-workspace', { 'your-name-word-count:toggle': () =&gt; this.toggle() }));  Next we have the toggle method. This method simply toggles the visibility of the modal panel that we created in the activate method. toggle() { console.log('YourNameWordCount was toggled!'); return ( this.modalPanel.isVisible() ? this.modalPanel.hide() : this.modalPanel.show() ); }  This should be fairly simple to understand. We're looking to see if the modal element is visible and hiding or showing it depending on its current state.  The Flow So, let's review the actual flow in this package.  Atom starts up Atom starts loading packages Atom reads your package.json  Atom loads keymaps, menus, styles and the main module Atom finishes loading packages At some point, the user executes your package command your-name-word-count:toggle  Atom executes the activate method in your main module which sets up the UI by creating the hidden modal view Atom executes the package command your-name-word-count:toggle which reveals the hidden modal view At some point, the user executes the your-name-word-count:toggle command again Atom executes the command which hides the modal view Eventually, Atom is shut down which can trigger any serializations that your package has defined   Tip: Keep in mind that the flow will be slightly different if you choose not to use activationCommands in your package.   Counting the Words So now that we understand what is happening, let's modify the code so that our little modal box shows us the current word count instead of static text. We'll do this in a very simple way. When the dialog is toggled, we'll count the words right before displaying the modal. So let's do this in the toggle command. If we add some code to count the words and ask the view to update itself, we'll have something like this: toggle() { if (this.modalPanel.isVisible()) { this.modalPanel.hide(); } else { const editor = atom.workspace.getActiveTextEditor(); const words = editor.getText().split(/\\s+/).length; this.yourNameWordCountView.setCount(words); this.modalPanel.show(); } }  Let's look at the 3 lines we've added. First we get an instance of the current editor object (where our text to count is) by calling atom.workspace.getActiveTextEditor(). Next we get the number of words by calling getText() on our new editor object, then splitting that text on whitespace with a regular expression and then getting the length of that array. Finally, we tell our view to update the word count it displays by calling the setCount() method on our view and then showing the modal again. Since that method doesn't yet exist, let's create it now. We can add this code to the end of our your-name-word-count-view.js file: setCount(count) { const displayText = `There are ${count} words.`; this.element.children[0].textContent = displayText; }  Pretty simple! We take the count number that was passed in and place it into a string that we then stick into the element that our view is controlling.  Note: To see your changes, you'll need to reload the code. You can do this by reloading the window (The window:reload command in the Command Palette). A common practice is to have two Atom windows, one for developing your package, and one for testing and reloading.    Basic Debugging You'll notice a few console.log statements in the code. One of the cool things about Atom being built on Chromium is that you can use some of the same debugging tools available to you that you have when doing web development. To open up the Developer Console, press Alt+Cmd+ICtrl+Shift+I, or choose the menu option View &gt; Developer &gt; Toggle Developer Tools.  From here you can inspect objects, run code and view console output just as though you were debugging a web site.  Testing Your package should have tests, and if they're placed in the spec directory, they can be run by Atom. Under the hood, Jasmine v1.3 executes your tests, so you can assume that any DSL available there is also available to your package.  Running Tests Once you've got your test suite written, you can run it by pressing Alt+Cmd+Ctrl+PAlt+Ctrl+P or via the View &gt; Developer &gt; Run Package Specs menu. Our generated package comes with an example test suite, so you can run this right now to see what happens.  You can also use the atom --test spec command to run them from the command line. It prints the test output and results to the console and returns the proper status code depending on whether the tests passed or failed.  Summary We've now generated, customized and tested our first plugin for Atom. Congratulations! Now let's go ahead and publish it so it's available to the world.",
          "excerpt": " Package: Word Count Let's get started by writing a very simple package and looking at some of the tools needed to develop one effectively. W…"
        },
      
    
      
        
        {
          "title": "Iconography",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/iconography/",
          "body": " Iconography Atom comes bundled with the Octicons 4.4.0 icon set. Use them to add icons to your packages.  NOTE: Some older icons from version 2.1.2 are still kept for backwards compatibility.   Overview In the Styleguide under the \"Icons\" section you'll find all the Octicons that are available.   Usage Octicons can be added with simple CSS classes in your markup. Prefix the icon names with icon icon-. As an example, to add a monitor icon (device-desktop), use the icon icon-device-desktop classes: &lt;span class=\"icon icon-device-desktop\"&gt;&lt;/span&gt;   Size Octicons look best with a font-size of 16px. It's already used as the default, so you don't need to worry about it. In case you prefer a different icon size, try to use multiples of 16 (32px, 48px etc.) for the sharpest result. Sizes in between are ok too, but might look a bit blurry for icons with straight lines.  Usability Although icons can make your UI visually appealing, when used without a text label, it can be hard to guess its meaning. In cases where space for a text label is insufficient, consider adding a tooltip that appears on hover. Or a more subtle title=\"label\" attribute would help as well.",
          "excerpt": " Iconography Atom comes bundled with the Octicons 4.4.0 icon set. Use them to add icons to your packages.  NOTE: Some older icons from versio…"
        },
      
    
      
        
        {
          "title": "Summary",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/summary/",
          "body": " Summary If you finished this chapter, you should be an Atom-hacking master. We've discussed how you should work with CoffeeScript, and how to put it to good use in creating packages. You should also be able to do this in your own created theme now. Even when something goes wrong, you should be able to debug this easily. But also fewer things should go wrong, because you are capable of writing great specs for Atom. In the next chapter, we’ll go into more of a deep dive on individual internal APIs and systems of Atom, even looking at some Atom source to see how things are really getting done.",
          "excerpt": " Summary If you finished this chapter, you should be an Atom-hacking master. We've discussed how you should work with CoffeeScript, and how t…"
        },
      
    
      
        
        {
          "title": "Debugging",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/debugging/",
          "body": " Debugging Atom provides several tools to help you understand unexpected behavior and debug problems. This guide describes some of those tools and a few approaches to help you debug and provide more helpful information when submitting issues:  Update to the Latest Version You might be running into an issue which was already fixed in a more recent version of Atom than the one you're using. If you're using a released version, check which version of Atom you're using:  atom --version Atom : 1.8.0 Electron: 0.36.8 Chrome : 47.0.2526.110 Node : 5.1.1  Then check for the latest Stable version.  If there is a more recent release available, you can update to the most recent release with the auto-update functionality built in to Atom and the about package. You can open the About View by using the Atom &gt; About menu option to see whether Atom is up-to-date, downloading a new update or click the button to \"Restart and Install Update\".   If there is a more recent release available, you can update to the most recent release with the auto-update functionality built in to Atom and the about package. You can open the About View by using the Help &gt; About menu option to see whether Atom is up-to-date, downloading a new update or click the button to \"Restart and Install Update\".   To update to the latest version, you can download it from the atom.io website or the latest release on GitHub and follow the Installation instructions for Atom on Linux.  If you're building Atom from source, pull down the latest version of master and re-build.  Using Safe Mode A large part of Atom's functionality comes from packages you can install. Atom will also execute the code in your init script on startup. In some cases, these packages and the code in the init script might be causing unexpected behavior, problems, or performance issues. To determine if that is happening, start Atom from the terminal in safe mode:  atom --safe  This starts Atom, but does not load packages from ~/.atom/packages or ~/.atom/dev/packages and disables loading of your init script. If you can no longer reproduce the problem in safe mode, it's likely it was caused by one of the packages or the init script. If removing or commenting out all content from the init script and starting Atom normally still produces the error, then try figuring out which package is causing trouble. Start Atom normally again and open the Settings View with Cmd+,Ctrl+,. Since the Settings View allows you to disable each installed package, you can disable packages one by one until you can no longer reproduce the issue. Restart Atom or reload Atom with Alt+Cmd+Ctrl+LCtrl+Shift+F5 after you disable each package to make sure it's completely gone. When you find the problematic package, you can disable or uninstall the package. We strongly recommend creating an issue on the package's GitHub repository. The Atom FAQ has information on how to contact the maintainers of any Atom community package or theme.  Clearing Saved State Atom saves a number of things about your environment when you exit in order to restore Atom to the same configuration when you next launch the program. In some cases the state that gets saved can be something undesirable that prevents Atom from working properly. In these cases, you may want to clear the state that Atom has saved.   Danger: Clearing the saved state permanently destroys any state that Atom has saved across all projects. This includes unsaved changes to files you may have been editing in all projects. This is a destructive action.  Clearing the saved state can be done by opening a terminal and executing:  atom --clear-window-state   Reset to Factory Defaults In some cases, you may want to reset Atom to \"factory defaults\", in other words clear all of your configuration and remove all packages. This can easily be done by opening a terminal and executing:   mv ~/.atom ~/.atom-backup     mv ~/.atom ~/.atom-backup     rename %USERPROFILE%\\.atom .atom-backup   Once that is complete, you can launch Atom as normal. Everything will be just as if you first installed Atom.  Tip: The command given above doesn't delete the old configuration, just puts it somewhere that Atom can't find it. If there are pieces of the old configuration you want to retrieve, you can find them in the ~/.atom-backup%USERPROFILE%\\.atom-backup directory.   Check for Linked Packages If you develop or contribute to Atom packages, there may be left-over packages linked to your ~/.atom/packages or ~/.atom/dev/packages directories. You can use the apm links command to list all linked packages:  apm links /Users/octocat/.atom/dev/packages (0) └── (no links) /Users/octocat/.atom/packages (1) └── color-picker -&gt; /Users/octocat/github/color-picker  You can remove links using the apm unlink command:  apm unlink color-picker Unlinking /Users/octocat/.atom/packages/color-picker ✓  See apm links --help and apm unlink --help for more information on these commands.  Tip: You can also use apm unlink --all to easily unlink all packages and themes.   Check for Incompatible Packages If you have packages installed that use native Node modules, when you upgrade to a new version of Atom, they might need to be rebuilt. Atom detects this and through the incompatible-packages package displays an indicator in the status bar when this happens.  If you see this indicator, click it and follow the instructions.  Check Atom and Package Settings In some cases, unexpected behavior might be caused by settings in Atom or in one of the packages. Open Atom's Settings View with Cmd+,Ctrl+,, the Atom &gt; PreferencesFile &gt; PreferencesEdit &gt; Preferences menu option, or the \"Settings View: Open\" command from the Command Palette.  Check Atom's settings in the Settings View, there's a description of most configuration options in the Basic Customization section. For example, if you want Atom to hide the invisible symbols representing whitespace characters, disable the \"Show Invisibles\" option. Some of these options are also available on a per-language basis which means that they may be different for specific languages, for example JavaScript or Python. To check the per-language settings, open the settings for the language package under the Packages tab in the Settings View, for example the language-javascript or language-python package. Since Atom ships with a set of packages and you can also install additional packages yourself, check the list of packages and their settings. For instance, if you'd like to get rid of the vertical line in the middle of the editor, disable the Wrap Guide package. And if you don't like it when Atom strips trailing whitespace or ensures that there's a single trailing newline in the file, you can configure that in the whitespace package's settings.   Check Your Configuration You might have defined some custom styles, keymaps or snippets in one of your configuration files. In some situations, these personal hacks might be causing the unexpected behavior you're observing so try clearing those files and restarting Atom.  Check Your Keybindings If a command is not executing when you press a key combination or the wrong command is executing, there might be an issue with the keybinding for that combination. Atom ships with the Keybinding Resolver, a neat package which helps you understand what key Atom saw you press and the command that was triggered because of it. Show the keybinding resolver with Cmd+.Ctrl+. or with \"Keybinding Resolver: Show\" from the Command palette. With the Keybinding Resolver shown, press a key combination:  The Keybinding Resolver shows you a list of keybindings that exist for the key combination, where each item in the list has the following:  the command for the keybinding the CSS selector used to define the context in which the keybinding is valid the file in which the keybinding is defined  The keybindings are listed in two colors. All the keybindings that are matched but not executed are shown in gray. The one that is executed, if any, is shown in green. If the command you wanted to trigger isn't listed, then a keybinding for that command hasn't been loaded. If multiple keybindings are matched, Atom determines which keybinding will be executed based on the specificity of the selectors and the order in which they were loaded. If the command you wanted to trigger is listed in the Keybinding Resolver, but wasn't the one that was executed, this is normally explained by one of two causes:   The key combination was not used in the context defined by the keybinding's selector For example, you can't trigger the keybinding for the tree-view:add-file command if the Tree View is not focused.   There is another keybinding that took precedence This often happens when you install a package which defines keybindings that conflict with existing keybindings. If the package's keybindings have selectors with higher specificity or were loaded later, they'll have priority over existing ones.   Atom loads core Atom keybindings and package keybindings first, and user-defined keybindings last. Since user-defined keybindings are loaded last, you can use your keymap.cson file to tweak the keybindings and sort out problems like these. See the Keymaps in Depth section for more information. If you notice that a package's keybindings are taking precedence over core Atom keybindings, it might be a good idea to report the issue on that package's GitHub repository. The Atom FAQ has information on how to contact the maintainers of any Atom community package or theme.  Check Font Rendering Issues You can determine which fonts are being used to render a specific piece of text by using the Developer Tools. To open the Developer Tools press Alt+Cmd+ICtrl+Shift+I. Once the Developer Tools are open, click the \"Elements\" tab. Use the standard tools for finding the element containing the text you want to check. Once you have selected the element, you can click the \"Computed\" tab in the styles pane and scroll to the bottom. The list of fonts being used will be shown there:   Check for Errors in the Developer Tools When an unexpected error occurs in Atom, you will normally see a red notification which provides details about the error and allows you to create an issue on the right repository:  If you can reproduce the error, use this approach to get the full stack trace and report the issue. Not all errors are logged with a notification so if you suspect you're experiencing an error but there's no notification, you can also look for errors in the developer tools Console tab. To access the Console tab, press Alt-Cmd-ICtrl-Shift-I to open developer tools and then click the Console tab:  If there are multiple errors, you can scroll down to the bottom of the panel to see the most recent error. Or while reproducing an error, you can right click in the Console tab panel, select Clear console to remove all Console output, and then reproduce the error to see what errors are logged to the Console tab.  Note: When running in Dev Mode, the developer tools are automatically shown with the error logged in the Console tab.   Find Crash Logs  When Atom crashes, you will find a crash dump in Console.app. You can launch Console.app using Spotlight or you can find it in /Applications/Utilities/Console.app. Once you have launched the program, you can find the latest crash dump by following these instructions:  Click \"User Reports\" in the left-most column Find the latest entry in the middle column that starts with Atom and ends with .crash   Once you have the crash dump, you can save it to send in later if it is needed for debugging.   When Atom crashes, you will find a crash dump inside your %TEMP%\\Atom Crashes directory. It will be the newest file with the .dmp extension. Once you have the crash dump, you can save it to send in later if it is needed for debugging.   When Atom crashes, it should write a core dump if system settings permit. In order to find whether the core dump is written and to where, consult the documentation for your distribution of Linux. Once you have the core dump, you can save it to send in later if it is needed for debugging.   Diagnose Startup Performance If Atom is taking a long time to start, you can use the Timecop package to get insight into where Atom spends time while loading.  Timecop displays the following information:  Atom startup times File compilation times Package loading and activation times Theme loading and activation times  If a specific package has high load or activation times, you might consider reporting an Issue to the maintainers. You can also disable the package to potentially improve future startup times.  Diagnose Runtime Performance If you're experiencing performance problems in a particular situation, your Issue reports will be more valuable if you include a saved profile from Chrome's CPU profiler that gives some insight into what is slow. To run a profile, open the Developer Tools with Alt+Cmd+ICtrl+Shift+I. From there:  Click the Profiles tab Select \"Collect JavaScript CPU Profile\" Click \"Start\"   Once that is done, then perform the slow action to capture a recording. When finished, click \"Stop\". Switch to the \"Chart\" view, and a graph of the recorded actions will appear. You can save and post the profile data by clicking \"Save\" next to the profile's name in the left panel.  To learn more, check out the Chrome documentation on CPU profiling.  Profiling Startup Performance If the time for loading the window looks high, you can create a CPU profile for that period using the --profile-startup command line flag when starting Atom:  atom --profile-startup .  This will automatically capture a CPU profile as Atom is loading and open the Developer Tools once Atom loads. From there:  Click the Profiles tab in the Developer Tools Select the \"startup\" profile Click the \"Save\" link for the startup profile  You can then include the startup profile in any Issue you report.  Check Your Build Tools If you are having issues installing a package using apm install, this could be because the package has dependencies on libraries that contain native code. This means you will need to have a C++ compiler and Python installed to be able to install it. You can run apm install --check to see if the Atom package manager can build native code on your machine. Check out the pre-requisites in the build instructions for your platform for more details.",
          "excerpt": " Debugging Atom provides several tools to help you understand unexpected behavior and debug problems. This guide describes some of those tool…"
        },
      
    
      
        
        {
          "title": "Creating a Grammar",
          "category": "",
          "category_url": "",
          "url": "/hacking-atom/sections/creating-a-grammar/",
          "body": " Creating a Grammar Grammars power Atom's syntax highlighting. Each grammar provides a set of regex (regular expression) patterns which are assigned scopes. These scopes are then turned into the CSS classes that you can target in syntax themes!  Note: This tutorial is a work in progress.   Getting Started Grammars depend heavily on regexes, and you should be comfortable with interpreting and writing regexes before continuing. Note that Atom uses the Oniguruma engine, which is very similar to the PCRE or Perl regex engines. Here are some resources to help you out:   https://www.regular-expressions.info/tutorial.html provides a comprehensive regex tutorial  https://www.rexegg.com/regex-quickstart.html contains a cheat sheet for various regex expressions  https://regex101.com/ or https://regexr.com/ allows live prototyping  Grammar files are written in the CSON or JSON format. Whichever one you decide to use is up to you, but this tutorial will be written in CSON.  Create the Package To get started, press Cmd+Shift+PCtrl+Shift+P and start typing \"Generate Package\" to generate a new grammar package. Select \"Package Generator: Generate Package,\" and you'll be asked for the path where your package will be created. Let's call ours language-flight-manual.  Tip: Grammar packages should start with language-.  The default package template creates a lot of folders that aren't needed for grammar packages. Go ahead and delete the keymaps, lib, menus, and styles folders. Furthermore, in package.json, remove the activationCommands section. Now create a new folder called grammars, and inside that a file called flight-manual.cson. This is the main file that we will be working with - start by populating it with a boilerplate template. Now let's go over what each key means. scopeName is the root scope of your package. This should generally describe what language your grammar package is highlighting; for example, language-javascript's scopeName is source.js and language-html's is text.html.basic. Name it source.flight-manual for now. name is the user-friendly name that is displayed in places like the status bar or the grammar selector. Again, this name should describe what the grammar package is highlighting. Rename it to Flight Manual. fileTypes is an array of filetypes that language-flight-manual should highlight. We're interested in highlighting the Flight Manual's Markdown files, so add the md extension to the list and remove the others. patterns contains the array of regex patterns that will determine how the file is tokenized.  Adding Patterns To start, let's add a basic pattern to tokenize the words Flight Manual whenever they show up. Your regex should look like \\bFlight Manual\\b. Here's what your patterns block should look like: 'patterns': [ { 'match': '\\\\bFlight Manual\\\\b' 'name': 'entity.other.flight-manual' } ]  match is where your regex is contained, and name is the scope name that is to be applied to the entirety of the match. More information about scope names can be found in Section 12.4 of the TextMate Manual.  Tip: All scopes should end with the portion of the root scopeName after the leading source or text. In our case, all scopes should end with flight-manual.   Note: Astute readers may have noticed that the \\b was changed to \\\\b with two backslashes and not one. This is because CSON processes the regex string before handing it to Oniguruma, so all backslashes need to be escaped twice.  But what if we wanted to apply different scopes to Flight and Manual? This is possible by adding capture groups to the regex and then referencing those capture groups in a new capture property. For example: 'match': '\\\\b(Flight) (Manual)\\\\b' 'name': 'entity.other.flight-manual' 'captures': '1': 'name': 'keyword.other.flight.flight-manual' '2': 'name': 'keyword.other.manual.flight-manual'  This will assign the scope keyword.other.flight.flight-manual to Flight, keyword.other.manual.flight-manual to Manual, and entity.other.flight-manual to the overarching Flight Manual.  Begin/End Patterns Now let's say we want to tokenize the {{#note}} blocks that occur in Flight Manual files. Our previous two examples used match, but one limit of match is that it can only match single lines. {{#note}} blocks, on the other hand, can span multiple lines. For these cases, you can use the begin/end keys. Once the regex in the begin key is matched, tokenization will continue until the end pattern is reached. 'begin': '({{)(#note)(}})' 'beginCaptures': '0': # The 0 capture contains the entire match 'name': 'meta.block.start.flight-manual' '1': 'name': 'punctuation.definition.block.flight-manual' '2': 'name': 'keyword.note.flight-manual' '3': 'name': 'punctuation.definition.block.flight-manual' 'end': '({{)(/note)(}})' 'endCaptures': '0': 'name': 'meta.block.end.flight-manual' '1': 'name': 'punctuation.definition.block.flight-manual' '2': 'name': 'keyword.note.flight-manual' '3': 'name': 'punctuation.definition.block.flight-manual' 'name': 'meta.block.note.flight-manual'   Tip: Get into the habit of providing punctuation scopes early on. It's much less effort than having to go back and rewriting all your patterns to support punctuation scopes when your grammar starts to get a bit longer!  Awesome, we have our first multiline pattern! However, if you've been following along and playing around in your own .md file, you may have noticed that Flight Manual doesn't receive any scopes inside a note block. A begin/end block is essentially a subgrammar of its own: once it starts matching, it will only match its own subpatterns until the end pattern is reached. Since we haven't defined any subpatterns, then clearly nothing will be matched inside of a note block. Let's fix that! 'begin': '({{)(#note)(}})' 'beginCaptures': '0': # The 0 capture contains the entire match 'name': 'meta.block.start.flight-manual' '1': 'name': 'punctuation.definition.block.flight-manual' '2': 'name': 'keyword.note.flight-manual' '3': 'name': 'punctuation.definition.block.flight-manual' 'end': '({{)(/note)(}})' 'endCaptures': '0': 'name': 'meta.block.end.flight-manual' '1': 'name': 'punctuation.definition.block.flight-manual' '2': 'name': 'keyword.note.flight-manual' '3': 'name': 'punctuation.definition.block.flight-manual' 'name': 'meta.block.note.flight-manual' 'patterns': [ { 'match': '\\\\b(Flight) (Manual)\\\\b' 'name': 'entity.other.flight-manual' 'captures': '1': 'name': 'keyword.other.flight.flight-manual' '2': 'name': 'keyword.other.manual.flight-manual' } ]  There. With the patterns block, Flight Manual should now receive the proper scopes.  Repositories and the Include keyword, or how to avoid duplication At this point, note blocks are looking pretty nice, as is the Flight Manual keyword, but the rest of the file is noticeably lacking any form of Markdown syntax highlighting. Is there a way to include the GitHub-Flavored Markdown grammar without copying and pasting everything over? This is where the include keyword comes in. include allows you to include other patterns, even from other grammars! language-gfm's scopeName is source.gfm, so let's include that. Our patterns block should now look like the following: 'patterns': [ { 'include': 'source.gfm' } { # Flight Manual pattern } { # Note begin/end pattern } ]  However, including source.gfm has led to another problem: note blocks still don't have any Markdown highlighting! The quick fix would be to add the include pattern to the note's pattern block as well, but now we're duplicating two patterns. You can imagine that as this grammar grows it'll quickly become inefficient to keep copying each new global pattern over to the note pattern as well. Therefore, include helpfully recognizes the special $self scope. $self automatically includes all the top-level patterns of the current grammar. The note block can then be simplified to the following: 'begin': '({{)(#note)(}})' # beginCaptures 'end': '({{)(/note)(}})' # endCaptures 'name': 'meta.block.note.flight-manual' 'patterns': [ { 'include': '$self' } ]  ",
          "excerpt": " Creating a Grammar Grammars power Atom's syntax highlighting. Each grammar provides a set of regex (regular expression) patterns which are a…"
        },
      
    
      
        
        {
          "title": "Atom Basics",
          "category": "",
          "category_url": "",
          "url": "/getting-started/sections/atom-basics/",
          "body": " Atom Basics Now that Atom is installed on your system, let's fire it up, configure it and get acquainted with the editor. When you launch Atom for the first time, you should get a screen that looks like this:  This is the Atom welcome screen and gives you a pretty good starting point for how to get started with the editor.  Terminology You can find definitions for all of the various terms that we use throughout the manual in our Glossary.  Command Palette In that welcome screen, we are introduced to probably the most important command in Atom, the Command Palette. If you press Cmd+Shift+PCtrl+Shift+P while focused in an editor pane, the command palette will pop up.  Throughout the book, we will use shortcut keybindings like Cmd+Shift+PCtrl+Shift+P to demonstrate how to run a command. These are the default keybindings for the platform that we detected you running. If you want to see a different platform than the one we detected, you may choose a different one by using the platform selector near the top of the page:  If the Platform Selector is not present, then the current page doesn't have any platform-specific content. If you have customized your Atom keymap, you can always see the keybinding you have mapped in the Command Palette or the Keybindings tab in the Settings View.  This search-driven menu can do just about any major task that is possible in Atom. Instead of clicking around all the application menus to look for something, you can press Cmd+Shift+PCtrl+Shift+P and search for the command.  Not only can you see and quickly search through thousands of possible commands, but you can also see if there is a keybinding associated with it. This is great because it means you can guess your way to doing interesting things while also learning the shortcut key strokes for doing it. For the rest of the book, we will try to be clear as to the text you can search for in the Command Palette in addition to the keybinding for different commands.  Settings and Preferences Atom has a number of settings and preferences you can modify in the Settings View.  This includes things like changing the theme, specifying how to handle wrapping, font settings, tab size, scroll speed and much more. You can also use this screen to install new packages and themes, which we'll cover in Atom Packages. To open the Settings View, you can:  Use the Atom &gt; PreferencesFile &gt; SettingsEdit &gt; Preferences menu item in the menu bar Search for settings-view:open in the Command Palette  Use the Cmd+,Ctrl+, keybinding   Changing the Theme The Settings View also lets you change the themes for Atom. Atom ships with 4 different UI themes, dark and light variants of the Atom and One theme, as well as 8 different syntax themes. You can modify the active theme or install new themes by clicking on the Themes tab in the sidebar of the Settings View.  The UI themes control the style of UI elements like the tabs and the tree view, while the syntax themes control the syntax highlighting of text you load into the editor. To change the syntax or UI theme, simply pick something different in the appropriate dropdown list. There are also dozens of themes on https://atom.io that you can choose from if you want something different. We will cover customizing a theme in Style Tweaks and creating your own theme in Creating a Theme.  Soft Wrap You can use the Settings View to specify your whitespace and wrapping preferences.  Enabling \"Soft Tabs\" will insert spaces instead of actual tab characters when you press the Tab key and the \"Tab Length\" setting specifies how many spaces to insert when you do so, or how many spaces are used to represent a tab if \"Soft Tabs\" is disabled. The \"Soft Wrap\" option will wrap lines that are too long to fit in your current window. If soft wrapping is disabled, the lines will simply run off the side of the screen and you will have to scroll the window to see the rest of the content. If \"Soft Wrap At Preferred Line Length\" is toggled, the lines will wrap at 80 characters instead of the end of the screen. You can also change the default line length to a value other than 80 on this screen. In Basic Customization we will see how to set different wrap preferences for different types of files (for example, if you want to wrap Markdown files but not other files).  Opening, Modifying, and Saving Files Now that your editor is looking and acting how you want, let's start opening up and editing files. This is a text editor after all, right?  Opening a File There are several ways to open a file in Atom. You can do it by choosing File &gt; Open from the menu bar or by pressing Cmd+OCtrl+O to choose a file from the standard dialog.  This is useful for opening a file that is not contained in the project you're currently in (more on that next), or if you're starting from a new window for some reason. Another way to open a file in Atom is from the command line using the atom command. The Atom menu bar has a command named \"Install Shell Commands\" which installs the atom and apm commands if Atom wasn't able to install them itself.The atom and apm commands are installed automatically as a part of Atom's installation process. You can run the atom command with one or more file paths to open up those files in Atom.  atom --help Atom Editor v1.8.0 Usage: atom [options] [path ...] One or more paths to files or folders may be specified. If there is an existing Atom window that contains all of the given folders, the paths will be opened in that window. Otherwise, they will be opened in a new window. ...  This is a great tool if you're used to the terminal or you work from the terminal a lot. Just fire off atom [files] and you're ready to start editing.  Editing and Saving a File Editing a file is pretty straightforward. You can click around and scroll with your mouse and type to change the content. There is no special editing mode or key commands. If you prefer editors with modes or more complex key commands, you should take a look at the Atom package list. There are a lot of packages that emulate popular styles. To save a file you can choose File &gt; Save from the menu bar or Cmd+SCtrl+S to save the file. If you choose File &gt; Save As or press Cmd+Shift+SCtrl+Shift+S then you can save the current content in your editor under a different file name. Finally, you can choose File &gt; Save All or press Alt+Cmd+S to save all the open files in Atom.  Opening Directories Atom doesn't just work with single files though; you will most likely spend most of your time working on projects with multiple files. To open a directory, choose the menu item File &gt; OpenFile &gt; Open Folder and select a directory from the dialog. You can also add more than one directory to your current Atom window, by choosing File &gt; Add Project Folder from the menu bar or pressing Cmd+Shift+OCtrl+Shift+A. You can open any number of directories from the command line by passing their paths to the atom command line tool. For example, you could run the command atom ./hopes ./dreams to open both the hopes and the dreams directories at the same time. When you open Atom with one or more directories, you will automatically get a Tree View on the side of your window.  The Tree View allows you to explore and modify the file and directory structure of your project. You can open, rename, delete and create new files from this view. You can also hide and show it with Cmd+\\Ctrl+\\ or the tree-view:toggle command from the Command Palette, and Ctrl+0Alt+\\ will focus it. When the Tree view has focus you can press A, M, or Delete to add, move or delete files and folders. You can also right-click on a file or folder in the Tree view to see many of the various options, including all of these plus showing the file in FinderWindows Exploreryour native filesystem or copying the file path to the clipboard.  Atom Packages Like many parts of Atom, the Tree View is not built directly into the editor, but is its own standalone package that is shipped with Atom by default. Packages that are bundled with Atom are referred to as Core packages. Ones that aren't bundled with Atom are referred to as Community packages. You can find the source code to the Tree View on GitHub at https://github.com/atom/tree-view. This is one of the interesting things about Atom. Many of its core features are actually just packages implemented the same way you would implement any other functionality. This means that if you don't like the Tree View for example, you could write your own implementation of that functionality and replace it entirely.   Opening a File in a Project Once you have a project open in Atom, you can easily find and open any file within that project. If you press Cmd+TCtrl+T or Cmd+PCtrl+P, the Fuzzy Finder will pop up. This will let you quickly search for any file in your project by typing parts of the path.  You can also search through only the files currently opened (rather than every file in your project) with Cmd+BCtrl+B. This searches through your \"buffers\" or open files. You can also limit this fuzzy search with Cmd+Shift+BCtrl+Shift+B, which searches only through the files which are new or have been modified since your last Git commit. The fuzzy finder uses the core.ignoredNames, fuzzy-finder.ignoredNames and core.excludeVCSIgnoredPaths configuration settings to filter out files and folders that will not be shown. If you have a project with tons of files you don't want it to search through, you can add patterns or paths to either of these config settings or your standard .gitignore files. We'll learn more about config settings in Global Configuration Settings, but for now you can easily set these in the Settings View under Core Settings. Both core.ignoredNames and fuzzy-finder.ignoredNames are interpreted as glob patterns as implemented by the minimatch Node module.  Configuration Setting Notation Sometimes you'll see us refer to configuration settings all spelled out like \"Ignored Names in Core Settings\". Other times you'll see us use the shorthand name like core.ignoredNames. Both of these refer to the same thing. The shorthand is the package name, then a dot ., followed by the \"camel-cased\" name of the setting. If you have a phrase you want to camel-case, follow these steps:  Lowercase the first word Capitalize the first letter in all other words Remove the spaces  So \"Ignored Names\" becomes \"ignoredNames\". ",
          "excerpt": " Atom Basics Now that Atom is installed on your system, let's fire it up, configure it and get acquainted with the editor. When you launch At…"
        },
      
    
      
        
        {
          "title": "Installing Atom",
          "category": "",
          "category_url": "",
          "url": "/getting-started/sections/installing-atom/",
          "body": " Installing Atom To get started with Atom, we'll need to get it on your system. This section will go over installing Atom on your system as well as the basics of how to build it from source. Installing Atom should be fairly simple. Generally, you can go to https://atom.io and at the top of the page you should see a download button as shown here:          The button or buttons should be specific to your platform and the download package should be easily installable. However, let's go over them here in a bit of detail.   Installing Atom on Mac Atom follows the standard Mac zip installation process. You can either press the download button from the https://atom.io site or you can go to the Atom releases page to download the atom-mac.zip file explicitly. Once you have that file, you can click on it to extract the application and then drag the new Atom application into your \"Applications\" folder. When you first open Atom, it will try to install the atom and apm commands for use in the terminal. In some cases, Atom might not be able to install these commands because it needs an administrator password. To check if Atom was able to install the atom command, for example, open a terminal window and type which atom. If the atom command has been installed, you'll see something like this:  which atom /usr/local/bin/atom $  If the atom command wasn't installed, the which command won't return anything:  which atom $  To install the atom and apm commands, run \"Window: Install Shell Commands\" from the Command Palette, which will prompt you for an administrator password.    Installing Atom on Windows Atom is available with a Windows installer that can be downloaded from https://atom.io or from the Atom releases page named AtomSetup.exe. This setup program will install Atom, add the atom and apm commands to your PATH, and create shortcuts on the desktop and in the start menu.  The context menu Open with Atom in File Explorer, and the option to make Atom available for file association using Open with..., is controlled by the System Settings panel as seen above. With Atom open, click on File &gt; Settings, and then the System tab on the left. Check the boxes next to Show in file context menus, as well as Show in folder context menus. And you’re all set.    Installing Atom on Linux You can install Atom on Linux using your distribution's package manager by configuring it to use one of our official package repositories. This will also enable you to update Atom when new releases are published.  Debian and Ubuntu (deb/apt) To install Atom on Debian, Ubuntu, or related distributions, add our official package repository to your system by running the following commands:  curl -L https://packagecloud.io/AtomEditor/atom/gpgkey | sudo apt-key add - sudo sh -c 'echo \"deb [arch=amd64] https://packagecloud.io/AtomEditor/atom/any/ any main\" &gt; /etc/apt/sources.list.d/atom.list' sudo apt-get update  You can now install Atom using apt-get (or apt on Ubuntu):  # Install Atom sudo apt-get install atom # Install Atom Beta sudo apt-get install atom-beta  Alternatively, you can download the Atom .deb package and install it directly:  # Install Atom sudo dpkg -i atom-amd64.deb # Install Atom's dependencies if they are missing sudo apt-get -f install   Red Hat and CentOS (YUM), or Fedora (DNF) To install Atom on CentOS, Oracle Linux, Red Hat Enterprise Linux, Scientific Linux, Fedora, or related distributions that use the YUM or DNF package managers, add our official package repository to your system by running the following commands:  sudo rpm --import https://packagecloud.io/AtomEditor/atom/gpgkey sudo sh -c 'echo -e \"[Atom]\\nname=Atom Editor\\nbaseurl=https://packagecloud.io/AtomEditor/atom/el/7/\\$basearch\\nenabled=1\\ngpgcheck=0\\nrepo_gpgcheck=1\\ngpgkey=https://packagecloud.io/AtomEditor/atom/gpgkey\" &gt; /etc/yum.repos.d/atom.repo'  You can now install Atom using dnf (or yum depending on your distribution):  # Install Atom sudo dnf install atom # Install Atom Beta sudo dnf install atom-beta  Alternatively, you can download the Atom .rpm package and install it directly:  # On YUM-based distributions sudo yum install -y atom.x86_64.rpm # On DNF-based distributions sudo dnf install -y atom.x86_64.rpm   SUSE (zypp) To install Atom on openSUSE or other distributions that use the Zypp package manager, add our official package repository to your system by running the following commands:  sudo sh -c 'echo -e \"[Atom]\\nname=Atom Editor\\nbaseurl=https://packagecloud.io/AtomEditor/atom/el/7/\\$basearch\\nenabled=1\\ntype=rpm-md\\ngpgcheck=0\\nrepo_gpgcheck=1\\ngpgkey=https://packagecloud.io/AtomEditor/atom/gpgkey\" &gt; /etc/zypp/repos.d/atom.repo' sudo zypper --gpg-auto-import-keys refresh  You can now install Atom using zypper:  # Install Atom sudo zypper install atom # Install Atom Beta sudo zypper install atom-beta  Alternatively, you can download the Atom .rpm package and install it directly:  sudo zypper in -y atom.x86_64.rpm    Portable Mode Atom stores configuration and state in a .atom directory usually located in your home directory (%userprofile% on Windows). You can however run Atom in portable mode where both the app and the configuration are stored together such as on a removable storage device. To setup Atom in portable mode download the zip/tar.gz package for your system and extract it to your removable storage.  Then create a .atom directory alongside the directory that contains atom.exe, for example: e:\\atom-1.14\\atom.exe e:\\.atom    Then create a .atom directory alongside the Atom.app application, for example: /MyUSB/Atom.app /MyUSB/.atom    Then create a .atom directory alongside the directory that contains the Atom binary, for example: /media/myusb/atom-1.14/atom /media/myusb/.atom    Portable Notes  The .atom directory must be writeable You can move an existing .atom directory to your portable device Atom can also store its Electron user data in your .atom directory - just create a subdirectory called electronUserData inside .atom  Alternatively you can set the ATOM_HOME environment variable to point wherever you want (you can write a .sh or .cmd script to temporarily set it and launch it from that) Portable mode installations will not automatically update   Building Atom from Source The Hacking on Atom Core section of the flight manual covers instructions on how to clone and build the source code if you prefer that option.  Proxy and Firewall Settings  Behind a Firewall? If you are behind a firewall and seeing SSL errors when installing packages you can disable strict SSL by running:  apm config set strict-ssl false   Using a Proxy? If you are using a HTTP(S) proxy you can configure apm to use it by running:  apm config set https-proxy YOUR_PROXY_ADDRESS  You can run apm config get https-proxy to verify it has been set correctly.",
          "excerpt": " Installing Atom To get started with Atom, we'll need to get it on your system. This section will go over installing Atom on your system as w…"
        },
      
    
      
        
        {
          "title": "Summary",
          "category": "",
          "category_url": "",
          "url": "/getting-started/sections/summary/",
          "body": " Summary You should now have a basic understanding of what Atom is and what you want to do with it. You should also have it installed on your system and be able to use it for the most basic text editing operations. Now you're ready to start digging into the fun stuff.",
          "excerpt": " Summary You should now have a basic understanding of what Atom is and what you want to do with it. You should also have it installed on your…"
        },
      
    
      
        
        {
          "title": "Why Atom?",
          "category": "",
          "category_url": "",
          "url": "/getting-started/sections/why-atom/",
          "body": " Why Atom? There are a lot of text editors out there; why should you spend your time learning about and using Atom? Editors like Sublime and TextMate offer convenience but only limited extensibility. On the other end of the spectrum, Emacs and Vim offer extreme flexibility, but they aren't very approachable and can only be customized with special-purpose scripting languages. We think we can do better. Our goal is a zero-compromise combination of hackability and usability: an editor that will be welcoming to an elementary school student on their first day learning to code, but also a tool they won't outgrow as they develop into seasoned hackers. As we've used Atom to build Atom, what began as an experiment has gradually matured into a tool we can't live without. On the surface, Atom is the modern desktop text editor you've come to expect. Pop the hood, however, and you'll discover a system begging to be hacked on.  The Nucleus of Atom The web is not without its faults, but two decades of development has forged it into an incredibly malleable and powerful platform. So when we set out to write a text editor that we ourselves would want to extend, web technology was the obvious choice. But first, we had to free it from its chains.  The Native Web Web browsers are great for browsing web pages, but writing code is a specialized activity that warrants dedicated tools. More importantly, the browser severely restricts access to the local system for security reasons, and for us, a text editor that couldn't write files or run local subprocesses was a non-starter. For this reason, we didn't build Atom as a traditional web application. Instead, Atom is a specialized variant of Chromium designed to be a text editor rather than a web browser. Every Atom window is essentially a locally-rendered web page. All the APIs available to a typical Node.js application are also available to the code running in each window's JavaScript context. This hybrid provides a unique client-side development experience. Since everything is local, you don't have to worry about asset pipelines, script concatenation, and asynchronous module definitions. If you want to load some code, just require it at the top of your file. Node's module system makes it easy to break the system down into lots of small, focused packages.  JavaScript, Meet C++ Interacting with native code is also really simple. For example, we wrote a wrapper around the Oniguruma regular expression engine for our TextMate grammar support. In a browser, that would have required adventures with NaCl or Esprima. Node integration made it easy. In addition to the Node APIs, we also expose APIs for native dialogs, adding application and context menu items, manipulating the window dimensions, etc.  Web Tech: The Fun Parts Another great benefit, that comes with writing code for Atom, is the guarantee that it's running on the newest version of Chromium. That means we can ignore issues like browser compatibility and polyfills. We can use all the web's shiny features of tomorrow, today. For example, the layout of our workspace and panes is based on flexbox. It's an emerging standard and has gone through a lot of change since we started using it, but none of that mattered as long as it worked. With the entire industry pushing web technology forward, we're confident that we're building Atom on fertile ground. Native UI technologies come and go, but the web is a standard that becomes more capable and ubiquitous with every passing year. We're excited to dig deeper into its toolbox.  An Open-Source Text Editor We see Atom as a perfect complement to GitHub's primary mission of building better software by working together. Atom is a long-term investment, and GitHub will continue to support its development with a dedicated team going forward. But we also know that we can't achieve our vision for Atom alone. As Emacs and Vim have demonstrated over the past three decades, if you want to build a thriving, long-lasting community around a text editor, it has to be open source. The entire Atom editor is free and open source and is available under the https://github.com/atom organization.",
          "excerpt": " Why Atom? There are a lot of text editors out there; why should you spend your time learning about and using Atom? Editors like Sublime and …"
        },
      
    
      
        
        {
          "title": "Removing Shadow DOM styles",
          "category": "",
          "category_url": "",
          "url": "/shadow-dom/sections/removing-shadow-dom-styles/",
          "body": " Removing Shadow DOM styles In Atom 1.13 the Shadow DOM got removed from text editors. For more background on the reasoning, check out the Pull Request where it was removed. In this guide you will learn how to migrate your theme or package.  Summary Here is a quick summary to see all the changes at a glance:    Before +/- After     atom-text-editor::shadow {} - ::shadow  atom-text-editor {}   .class /deep/ .class {} - /deep/  .class .class {}   atom-text-editor, :host {} - :host  atom-text-editor {}   .comment {} + .syntax--  .syntax--comment {}    Below you'll find more detailed examples.  UI themes and packages  ::shadow  Remove the ::shadow pseudo-element selector from atom-text-editor. Before: atom-text-editor::shadow .cursor { border-color: hotpink; }  After: atom-text-editor .cursor { border-color: hotpink; }   /deep/  Remove the /deep/ combinator selector. It didn't get used that often, mainly to customize the scrollbars. Before: .scrollbars-visible-always /deep/ ::-webkit-scrollbar { width: 8px; height: 8px; }  After: .scrollbars-visible-always ::-webkit-scrollbar { width: 8px; height: 8px; }   Syntax themes  :host  Remove the :host pseudo-element selector. To scope any styles to the text editor, using atom-text-editor is already enough. Before: atom-text-editor, :host { .cursor { border-color: hotpink; } }  After: atom-text-editor { .cursor { border-color: hotpink; } }   syntax--  Add a syntax-- prefix to all grammar selectors used by language packages. It looks a bit verbose, but it will protect all the grammar selectors from accidental style pollution. Before: .comment { color: @mono-3; font-style: italic; .markup.link { color: @mono-3; } }  After: .syntax--comment { color: @mono-3; font-style: italic; .syntax--markup.syntax--link { color: @mono-3; } }  Note: Selectors like the .gutter, .indent-guide, .cursor among others, that are also part of Syntax themes, don't need a prefix. Only grammar selectors that get used by language packages. For example .syntax--keyword, .syntax--keyword.syntax--operator.syntax--js.  Context-Targeted Style Sheets Atom also allowed you to target a specific shadow DOM context with an entire style sheet by adding .atom-text-editor to the file name. This is now not necessary anymore and can be removed. Before: my-ui-theme/ styles/ index.atom-text-editor.less  After: my-ui-theme/ styles/ index.less   I followed the guide, but now my styling is broken! By replacing atom-text-editor::shadow with atom-text-editor.editor, specificity might have changed. This can cause the side effect that some of your properties won't be strong enough. To fix that, you can increase specificity on your selector. A simple way is to just repeat your class (in the example below it's .my-class): Before: atom-text-editor::shadow .my-class { color: hotpink; }  After: atom-text-editor .my-class.my-class { color: hotpink; }   When should I migrate my theme/package?  If you already want to test the migration on master or Beta channel, make sure to change your package.json file to \"engines\": { \"atom\": \"&gt;=1.13.0 &lt;2.0.0\" }. This will prevent Atom from updating your theme or package before the user also updates Atom to version 1.13. Or you can wait until Atom 1.13 reaches Stable. Check blog.atom.io to see if 1.13 already has been released. Don't worry if you're a bit late, Atom will transform the deprecated selectors automatically to avoid breaking any themes or packages. But users will start to see a deprecation warning in deprecation-cop. ",
          "excerpt": " Removing Shadow DOM styles In Atom 1.13 the Shadow DOM got removed from text editors. For more background on the reasoning, check out the Pu…"
        },
      
    
      
        
        {
          "title": "Atom package server API",
          "category": "",
          "category_url": "",
          "url": "/atom-server-side-apis/sections/atom-package-server-api/",
          "body": " Atom package server API This guide describes the web API used by apm and Atom. The vast majority of use cases are met by the apm command-line tool, which does other useful things like incrementing your version in package.json and making sure you have pushed your git tag. In fact, Atom itself shells out to apm rather than hitting the API directly. If you're curious about how Atom uses apm, see the PackageManager class in the settings-view package.  Warning: This API should be considered pre-release and is subject to change.   Authorization For calls to the API that require authentication, provide a valid token from your atom.io account page in the Authorization header.  Media type All requests that take parameters require application/json.  API Resources  Packages  Listing packages  GET /api/packages Parameters:   page (optional)  sort (optional) - One of downloads, created_at, updated_at, stars. Defaults to downloads   direction (optional) - asc or desc. Defaults to desc. stars can only be ordered desc   Returns a list of all packages in the following format:  [ { \"releases\": { \"latest\": \"0.6.0\" }, \"name\": \"thedaniel-test-package\", \"repository\": { \"type\": \"git\", \"url\": \"https://github.com/thedaniel/test-package\" } }, ... ]  Results are paginated 30 at a time, and links to the next and last pages are provided in the Link header: Link: &lt;https://www.atom.io/api/packages?page=1&gt;; rel=\"self\", &lt;https://www.atom.io/api/packages?page=41&gt;; rel=\"last\", &lt;https://www.atom.io/api/packages?page=2&gt;; rel=\"next\"  By default, results are sorted by download count, descending.  Searching packages  GET /api/packages/search Parameters:   q (required) - Search query  page (optional)  sort (optional) - One of downloads, created_at, updated_at, stars. Defaults to the relevance of the search query.  direction (optional) - asc or desc. Defaults to desc.  Returns results in the same format as listing packages.  Showing package details  GET /api/packages/:package_name Returns package details and versions for a single package Parameters:   engine (optional) - Only show packages with versions compatible with this Atom version. Must be valid SemVer.  Returns:  { \"releases\": { \"latest\": \"0.6.0\" }, \"name\": \"thedaniel-test-package\", \"repository\": { \"type\": \"git\", \"url\": \"https://github.com/thedaniel/test-package\" }, \"versions\": [ (see single version output below) ..., ] }   Creating a package  POST /api/packages Create a new package; requires authentication. The name and version will be fetched from the package.json file in the specified repository. The authenticating user must have access to the indicated repository. Parameters:   repository - String. The repository containing the plugin, in the form \"owner/repo\"  Returns:   201 - Successfully created, returns created package.  400 - Repository is inaccessible, nonexistent, not an atom package. Possible error messages include:  That repo does not exist, isn't an atom package, or atombot does not have access The package.json at owner/repo isn't valid    409 - A package by that name already exists   Deleting a package  DELETE /api/packages/:package_name Delete a package; requires authentication. Returns:   204 - Success  400 - Repository is inaccessible  401 - Unauthorized   Renaming a package Packages are renamed by publishing a new version with the name changed in package.json. See Creating a new package version for details. Requests made to the previous name will forward to the new name.  Package Versions  GET /api/packages/:package_name/versions/:version_name Returns package.json with dist key added for e.g. tarball download:  { \"bugs\": { \"url\": \"https://github.com/thedaniel/test-package/issues\" }, \"dependencies\": { \"async\": \"~0.2.6\", \"pegjs\": \"~0.7.0\", \"season\": \"~0.13.0\" }, \"description\": \"Expand snippets matching the current prefix with `tab`.\", \"dist\": { \"tarball\": \"https://codeload.github.com/...\" }, \"engines\": { \"atom\": \"*\" }, \"main\": \"./lib/snippets\", \"name\": \"thedaniel-test-package\", \"publishConfig\": { \"registry\": \"https://...\", }, \"repository\": { \"type\": \"git\", \"url\": \"https://github.com/thedaniel/test-package.git\" }, \"version\": \"0.6.0\" }   Creating a new package version  POST /api/packages/:package_name/versions Creates a new package version from a git tag; requires authentication. If rename is not true, the name field in package.json must match the current package name. Parameters:   tag - A git tag for the version you'd like to create. It's important to note that the version name will not be taken from the tag, but from the version key in the package.json file at that ref. The authenticating user must have access to the package repository.  rename - Boolean indicating whether this version contains a new name for the package.  Returns:   201 - Successfully created. Returns created version.  400 - Git tag not found / Repository inaccessible / package.json invalid  409 - Version exists   Deleting a version  DELETE /api/packages/:package_name/versions/:version_name Deletes a package version; requires authentication. Note that a version cannot be republished with a different tag if it is deleted. If you need to delete the latest version of a package for example for security reasons, you'll need to increment the version when republishing. Returns 204 No Content  Stars  Listing user stars  GET /api/users/:login/stars List a user's starred packages. Return value is similar to GET /api/packages  GET /api/stars List the authenticated user's starred packages; requires authentication. Return value is similar to GET /api/packages  Starring a package  POST /api/packages/:name/star Star a package; requires authentication. Returns a package.  Unstarring a package  DELETE /api/packages/:name/star Unstar a package; requires authentication. Returns 204 No Content.  Listing a package's stargazers  GET /api/packages/:name/stargazers List the users that have starred a package. Returns a list of user objects: [ {\"login\":\"aperson\"}, {\"login\":\"anotherperson\"}, ] ",
          "excerpt": " Atom package server API This guide describes the web API used by apm and Atom. The vast majority of use cases are met by the apm command-lin…"
        },
      
    
      
        
        {
          "title": "Atom update server API",
          "category": "",
          "category_url": "",
          "url": "/atom-server-side-apis/sections/atom-update-server-api/",
          "body": " Atom update server API  Warning: This API should be considered pre-release and is subject to change.   Atom updates  Listing Atom updates  GET /api/updates Atom update feed, following the format expected by Squirrel. Returns: { \"name\": \"0.96.0\", \"notes\": \"[HTML release notes]\", \"pub_date\": \"2014-05-19T15:52:06.000Z\", \"url\": \"https://www.atom.io/api/updates/download\" } ",
          "excerpt": " Atom update server API  Warning: This API should be considered pre-release and is subject to change.   Atom updates  Listing Atom updates  G…"
        },
      
    
      
        
        {
          "title": "Glossary",
          "category": "",
          "category_url": "",
          "url": "/resources/sections/glossary/",
          "body": " Glossary Below is a list of some useful terms we use with regard to Atom.  Buffer A buffer is the text content of a file in Atom. It's basically the same as a file for most descriptions, but it's the version Atom has in memory. For instance, you can change the text of a buffer and it isn't written to its associated file until you save it.  Command A command is a bit of functionality in Atom that can be triggered by the user either through a keybinding or a menu item.  Dock Docks are collapsible pane containers that attach to the left, right, and bottom sides of the Atom window. Examples:  Tree View Git GitHub   Key Combination A key combination is some combination or sequence of keys that are pressed to perform a task. Examples:  A Ctrl+Enter  Ctrl+K Right    Key Sequence A key sequence is a special case of a key combination. It is a key combination that consists of keys that must be pressed and released in sequence. Ctrl+K Down is a key sequence. Alt+S is not a key sequence because it is two keys that are pressed and released together rather than in succession.  Keybinding A keybinding is the mapping of a key combination, such as Ctrl+Enter to an Atom command.  Keymap A keymap is a collection of keybindings. It can also refer to a file or files containing keybindings for an Atom package or Atom itself.  Package An Atom plugin. There is a bunch more information in the section on Atom Packages.  Pane A pane is a visual section of the editor space. Each pane can hold multiple pane items. There is always at least one pane in each Atom window.  Pane Container A section of the Atom UI that can contain multiple panes.  Pane Item Some item, often an editor, that is displayed within a pane. In the default configuration of Atom, pane items are represented by tabs at the top of each pane.  Note: The reason why we don't call them \"tabs\" is because you can disable the tabs package and then there aren't any tabs. For a similar reason, we don't call them files because some things can be shown in a pane that aren't files, like the Settings View.   Panel A piece of the Atom UI that is outside the editor space. Examples:  Find and Replace Keybinding Resolver ",
          "excerpt": " Glossary Below is a list of some useful terms we use with regard to Atom.  Buffer A buffer is the text content of a file in Atom. It's basic…"
        },
      
    
      
        
        {
          "title": "Developing Node Modules",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/developing-node-modules/",
          "body": " Developing Node Modules Atom contains a number of packages that are Node modules instead of Atom packages. If you want to make changes to the Node modules, for instance atom-keymap, you have to link them into the development environment differently than you would a normal Atom package.  Linking a Node Module Into Your Atom Dev Environment Here are the steps to run a local version of a Node module within Atom. We're using atom-keymap as an example:  git clone https://github.com/atom/atom-keymap.git cd atom-keymap npm install npm link cd WHERE YOU CLONED ATOM npm link atom-keymap # This is the special step, it makes the Node module work with Atom's version of Node apm rebuild # If you have cloned Atom in a different location than ~/github/atom%USERPROFILE%\\github\\atom # you need to set the following environment variable exportsetx ATOM_DEV_RESOURCE_PATH=WHERE YOU CLONED ATOM # Should work! atom --dev .  After you get the Node module linked and working, every time you make a change to the Node module's code, you will have to exit Atom and do the following:  cd WHERE YOU CLONED THE NODE MODULE npm install cd WHERE YOU CLONED ATOM apm rebuild atom --dev . ",
          "excerpt": " Developing Node Modules Atom contains a number of packages that are Node modules instead of Atom packages. If you want to make changes to th…"
        },
      
    
      
        
        {
          "title": "Keymaps In-Depth",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/keymaps-in-depth/",
          "body": " Keymaps In-Depth  Structure of a Keymap File Keymap files are encoded as JSON or CSON files containing nested hashes. They work much like style sheets, but instead of applying style properties to elements matching the selector, they specify the meaning of keystrokes on elements matching the selector. Here is an example of some bindings that apply when keystrokes pass through atom-text-editor elements:  'atom-text-editor': 'cmd-delete': 'editor:delete-to-beginning-of-line' 'alt-backspace': 'editor:delete-to-beginning-of-word' 'ctrl-A': 'editor:select-to-first-character-of-line' 'ctrl-shift-e': 'editor:select-to-end-of-line' 'cmd-left': 'editor:move-to-first-character-of-line' 'atom-text-editor:not([mini])': 'cmd-alt-[': 'editor:fold-current-row' 'cmd-alt-]': 'editor:unfold-current-row'    'atom-text-editor': 'ctrl-left': 'editor:move-to-beginning-of-word' 'ctrl-right': 'editor:move-to-end-of-word' 'ctrl-shift-left': 'editor:select-to-beginning-of-word' 'ctrl-shift-right': 'editor:select-to-end-of-word' 'ctrl-backspace': 'editor:delete-to-beginning-of-word' 'ctrl-delete': 'editor:delete-to-end-of-word' 'atom-text-editor:not([mini])': 'ctrl-alt-[': 'editor:fold-current-row' 'ctrl-alt-]': 'editor:unfold-current-row'    'atom-text-editor': 'ctrl-left': 'editor:move-to-beginning-of-word' 'ctrl-right': 'editor:move-to-end-of-word' 'ctrl-shift-left': 'editor:select-to-beginning-of-word' 'ctrl-shift-right': 'editor:select-to-end-of-word' 'ctrl-backspace': 'editor:delete-to-beginning-of-word' 'ctrl-delete': 'editor:delete-to-end-of-word' 'atom-text-editor:not([mini])': 'ctrl-alt-[': 'editor:fold-current-row' 'ctrl-alt-]': 'editor:unfold-current-row'   Beneath the first selector are several keybindings, mapping specific key combinations to commands. When an element with the atom-text-editor class is focused and Alt+BackspaceCtrl+Backspace is pressed, a custom DOM event called editor:delete-to-beginning-of-word is emitted on the atom-text-editor element. The second selector group also targets editors, but only if they don't have the mini attribute. In this example, the commands for code folding don't really make sense on mini-editors, so the selector restricts them to regular editors.  Key Combinations Key combinations express one or more keys combined with optional modifier keys. For example: ctrl-w v, or cmd-shift-up. A key combination is composed of the following symbols, separated by a -. A key sequence can be expressed as key combinations separated by spaces.    Type Examples     Character literals  a 4 $    Modifier keys  cmd ctrl alt shift    Special keys  enter escape backspace delete tab home end pageup pagedown left right up down space      Commands Commands are custom DOM events that are triggered when a key combination or sequence matches a binding. This allows user interface code to listen for named commands without specifying the specific keybinding that triggers it. For example, the following code creates a command to insert the current date in an editor: atom.commands.add 'atom-text-editor', 'user:insert-date': (event) -&gt; editor = @getModel() editor.insertText(new Date().toLocaleString())  atom.commands refers to the global CommandRegistry instance where all commands are set and consequently picked up by the command palette. When you are looking to bind new keys, it is often useful to use the Command Palette (Cmd+Shift+PCtrl+Shift+P) to discover what commands are being listened for in a given focus context. Commands are \"humanized\" following a simple algorithm, so a command like editor:fold-current-row would appear as \"Editor: Fold Current Row\".  \"Composed\" Commands A common question is, \"How do I make a single keybinding execute two or more commands?\" There isn't any direct support for this in Atom, but it can be achieved by creating a custom command that performs the multiple actions you desire and then creating a keybinding for that command. For example, let's say I want to create a \"composed\" command that performs a Select Line followed by Cut. You could add the following to your init.coffee: atom.commands.add 'atom-text-editor', 'custom:cut-line', -&gt; editor = atom.workspace.getActiveTextEditor() editor.selectLinesContainingCursors() editor.cutSelectedText()  Then let's say we want to map this custom command to alt-ctrl-z, you could add the following to your keymap: 'atom-text-editor': 'alt-ctrl-z': 'custom:cut-line'   Specificity and Cascade Order As is the case with CSS applying styles, when multiple bindings match for a single element, the conflict is resolved by choosing the most specific selector. If two matching selectors have the same specificity, the binding for the selector appearing later in the cascade takes precedence. Currently, there's no way to specify selector ordering within a single keymap, because JSON objects do not preserve order. We handle cases where selector ordering is critical by breaking the keymap into separate files, such as snippets-1.cson and snippets-2.cson.  Selectors and Custom Packages If a keybinding should only apply to a specific grammar, you can limit bindings to that grammar using the data-grammar attribute on the atom-text-editor element: \"atom-text-editor[data-grammar='source example']\": 'ctrl-.': 'custom:custom-command'  While selectors can be applied to the entire editor by what grammar is associated with it, they cannot be applied to scopes defined within the grammar or to sub-elements of atom-text-editor.  Removing Bindings When the keymap system encounters a binding with the unset! directive as its command, it will treat the current element as if it had no key bindings matching the current keystroke sequence and continue searching from its parent. For example, the following code removes the keybinding for a in the Tree View, which is normally used to trigger the tree-view:add-file command: '.tree-view': 'a': 'unset!'   But if some element above the Tree View had a keybinding for a, that keybinding would still execute even when the focus is inside the Tree View. When the keymap system encounters a binding with the abort! directive as its command, it will stop searching for a keybinding. For example, the following code removes the keybinding for Cmd+OCtrl+O when the selection is inside an editor pane:  'atom-text-editor': 'cmd-o': 'abort!'    'atom-text-editor': 'ctrl-o': 'abort!'    'atom-text-editor': 'ctrl-o': 'abort!'   But if you click inside the Tree View and press Cmd+OCtrl+O, it will work.  Forcing Chromium's Native Keystroke Handling If you want to force the native browser behavior for a given keystroke, use the native! directive as the command of a binding. This can be useful to enable the correct behavior in native input elements. If you apply the .native-key-bindings class to an element, all the keystrokes typically handled by the browser will be assigned the native! directive.  Tip: Components and input elements may not correctly handle backspace and arrow keys without forcing this behavior. If your backspace isn't working correctly inside of a component, add either the directive or the .native-key-bindings class.   Overloading Key Bindings Occasionally, it makes sense to layer multiple actions on top of the same key binding. An example of this is the snippets package. Snippets are inserted by typing a snippet prefix such as for and then pressing Tab. Every time Tab is pressed, we want to execute code attempting to expand a snippet if one exists for the text preceding the cursor. If a snippet doesn't exist, we want Tab to actually insert whitespace. To achieve this, the snippets package makes use of the .abortKeyBinding() method on the event object representing the snippets:expand command. # pseudo-code editor.command 'snippets:expand', (e) =&gt; if @cursorFollowsValidPrefix() @expandSnippet() else e.abortKeyBinding()  When the event handler observes that the cursor does not follow a valid prefix, it calls e.abortKeyBinding(), telling the keymap system to continue searching for another matching binding.  Step-by-Step: How Keydown Events are Mapped to Commands  A keydown event occurs on a focused element. Starting at the focused element, the keymap walks upward towards the root of the document, searching for the most specific CSS selector that matches the current DOM element and also contains a keystroke pattern matching the keydown event. When a matching keystroke pattern is found, the search is terminated and the pattern's corresponding command is triggered on the current element. If .abortKeyBinding() is called on the triggered event object, the search is resumed, triggering a binding on the next-most-specific CSS selector for the same element or continuing upward to parent elements. If no bindings are found, the event is handled by Chromium normally.   Overriding Atom's Keyboard Layout Recognition Sometimes the problem isn't mapping the command to a key combination, the problem is that Atom doesn't recognize properly what keys you're pressing. This is due to some limitations in how Chromium reports keyboard events. But even this can be customized now. You can add the following to your init.coffee to send Ctrl+@ when you press Ctrl+Alt+G: atom.keymaps.addKeystrokeResolver ({event}) -&gt; if event.code is 'KeyG' and event.altKey and event.ctrlKey and event.type isnt 'keyup' return 'ctrl-@'  Or if you've converted your init script to JavaScript: atom.keymaps.addKeystrokeResolver(({event}) =&gt; { if (event.code === 'KeyG' &amp;&amp; event.altKey &amp;&amp; event.ctrlKey &amp;&amp; event.type !== 'keyup') { return 'ctrl-@' } }) ",
          "excerpt": " Keymaps In-Depth  Structure of a Keymap File Keymap files are encoded as JSON or CSON files containing nested hashes. They work much like st…"
        },
      
    
      
        
        {
          "title": "Serialization in Atom",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/serialization-in-atom/",
          "body": " Serialization in Atom When a window is refreshed or restored from a previous session, the view and its associated objects are deserialized from a JSON representation that was stored during the window's previous shutdown. For your own views and objects to be compatible with refreshing, you'll need to make them play nicely with the serializing and deserializing.  Package Serialization Hook Your package's main module can optionally include a serialize method, which will be called before your package is deactivated. You should return a JSON-serializable object, which will be handed back to you as an object argument to activate next time it is called. In the following example, the package keeps an instance of MyObject in the same state across refreshes. module.exports = activate: (state) -&gt; @myObject = if state atom.deserializers.deserialize(state) else new MyObject(\"Hello\") serialize: -&gt; @myObject.serialize()   Serialization Methods class MyObject constructor: (@data) -&gt; serialize: -&gt; { deserializer: 'MyObject', data: @data }   serialize()  Objects that you want to serialize should implement .serialize(). This method should return a serializable object, and it must contain a key named deserializer whose value is the name of a registered deserializer that can convert the rest of the data to an object. It's usually just the name of the class itself.  Registering Deserializers The other side of the coin is deserializers, whose job is to convert a state object returned from a previous call to serialize back into a genuine object.  deserializers in package.json  The preferred way to register deserializers is via your package's package.json file: { \"name\": \"wordcount\", ... \"deserializers\": { \"MyObject\": \"deserializeMyObject\" } }  Here, the key (\"MyObject\") is the name of the deserializer—the same string used by the deserializer field in the object returned by your serialize() method. The value (\"deserializeMyObject\") is the name of a function in your main module that'll be passed the serialized data and will return a genuine object. For example, your main module might look like this: module.exports = deserializeMyObject: ({data}) -&gt; new MyObject(data)  Now you can call the global deserialize method with state returned from serialize, and your class's deserialize method will be selected automatically.  atom.deserializers.add(klass) An alternative is to use the atom.deserializers.add method with your class in order to make it available to the deserialization system. Usually this is used in conjunction with a class-level deserialize method: class MyObject atom.deserializers.add(this) @deserialize: ({data}) -&gt; new MyObject(data) constructor: (@data) -&gt; serialize: -&gt; { deserializer: 'MyObject', data: @data }  While this used to be the standard method of registering a deserializer, the package.json method is now preferred since it allows Atom to defer loading and executing your code until it's actually needed.  Versioning class MyObject atom.deserializers.add(this) @version: 2 @deserialize: (state) -&gt; ... serialize: -&gt; { version: @constructor.version, ... }  Your serializable class can optionally have a class-level @version property and include a version key in its serialized state. When deserializing, Atom will only attempt to call deserialize if the two versions match, and otherwise return undefined. We plan on implementing a migration system in the future, but this at least protects you from improperly deserializing old state.",
          "excerpt": " Serialization in Atom When a window is refreshed or restored from a previous session, the view and its associated objects are deserialized f…"
        },
      
    
      
        
        {
          "title": "Configuration API",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/configuration-api/",
          "body": " Configuration API  Reading Config Settings If you are writing a package that you want to make configurable, you'll need to read config settings via the atom.config global. You can read the current value of a namespaced config key with atom.config.get: # read a value with `config.get` @showInvisibles() if atom.config.get \"editor.showInvisibles\"  Or you can subscribe via atom.config.observe to track changes from any view object. {View} = require 'space-pen' class MyView extends View attached: -&gt; @fontSizeObserveSubscription = atom.config.observe 'editor.fontSize', (newValue, {previous}) =&gt; @adjustFontSize(newValue) detached: -&gt; @fontSizeObserveSubscription.dispose()  The atom.config.observe method will call the given callback immediately with the current value for the specified key path, and it will also call it in the future whenever the value of that key path changes. If you only want to invoke the callback the next time the value changes, use atom.config.onDidChange instead. Subscription methods return Disposable objects that can be used to unsubscribe. Note in the example above how we save the subscription to the @fontSizeObserveSubscription instance variable and dispose of it when the view is detached. To group multiple subscriptions together, you can add them all to a CompositeDisposable that you dispose when the view is detached.  Writing Config Settings The atom.config database is populated on startup from ~/.atom/config.cson%USERPROFILE%\\.atom\\config.cson, but you can programmatically write to it with atom.config.set: # basic key update atom.config.set(\"core.showInvisibles\", true)  If you're exposing package configuration via specific key paths, you'll want to associate them with a schema in your package's main module. Read more about schemas in the Config API documentation.",
          "excerpt": " Configuration API  Reading Config Settings If you are writing a package that you want to make configurable, you'll need to read config setti…"
        },
      
    
      
        
        {
          "title": "How Atom Uses Chromium Snapshots",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/how-atom-uses-chromium-snapshots/",
          "body": " How Atom Uses Chromium Snapshots In order to improve startup time, when Atom is built we create a V8 snapshot in which we preload core services and packages. Then, at runtime, we finish loading Atom by supplying all the information we didn't have during the compilation phase (e.g. loading third party packages, custom style sheets, configuration, etc.). electron-link is the tool that powers snapshots, as it enables us to traverse the entire require graph (starting at the entry point) and replace all the forbidden require calls (e.g. require calls to native modules, node core modules or other modules that can't be accessed in the snapshot V8 context) with a function that will be called at runtime. When adding new code to Atom, we always try to put it inside the snapshot by, for example, deferring the usage of DOM APIs or native node modules to a later moment in time when those facilities are available. If that is not possible, we will add the unsupported code paths to the list of files that get excluded from the snapshot, ensuring we only exclude those ones that are not supported as opposed to skipping an entire Node module. The output of electron-link is a single script containing the code for all the modules reachable from the entry point, which we then supply to mksnapshot to generate a snapshot blob. The generated blob is finally copied into the application bundle and will be automatically loaded by Electron when running Atom.",
          "excerpt": " How Atom Uses Chromium Snapshots In order to improve startup time, when Atom is built we create a V8 snapshot in which we preload core servi…"
        },
      
    
      
        
        {
          "title": "Interacting With Other Packages Via Services",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/interacting-with-other-packages-via-services/",
          "body": " Interacting With Other Packages Via Services Atom packages can interact with each other through versioned APIs called services. To provide a service, in your package.json, specify one or more version numbers, each paired with the name of a method on your package's main module: { \"providedServices\": { \"my-service\": { \"description\": \"Does a useful thing\", \"versions\": { \"1.2.3\": \"provideMyServiceV1\", \"2.3.4\": \"provideMyServiceV2\" } } } }  In your package's main module, implement the methods named above. These methods will be called any time a package is activated that consumes their corresponding service. They should return a value that implements the service's API. module.exports = activate: -&gt; # ... provideMyServiceV1: -&gt; adaptToLegacyAPI(myService) provideMyServiceV2: -&gt; myService  Similarly, to consume a service, specify one or more version ranges, each paired with the name of a method on the package's main module: { \"consumedServices\": { \"another-service\": { \"versions\": { \"^1.2.3\": \"consumeAnotherServiceV1\", \"&gt;=2.3.4 &lt;2.5\": \"consumeAnotherServiceV2\" } } } }  These methods will be called any time a package is activated that provides their corresponding service. They will receive the service object as an argument. You will usually need to perform some kind of cleanup in the event that the package providing the service is deactivated. To do this, return a Disposable from your service-consuming method: {Disposable} = require 'atom' module.exports = activate: -&gt; # ... consumeAnotherServiceV1: (service) -&gt; useService(adaptServiceFromLegacyAPI(service)) new Disposable -&gt; stopUsingService(service) consumeAnotherServiceV2: (service) -&gt; useService(service) new Disposable -&gt; stopUsingService(service) ",
          "excerpt": " Interacting With Other Packages Via Services Atom packages can interact with each other through versioned APIs called services. To provide a…"
        },
      
    
      
        
        {
          "title": "Maintaining Your Packages",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/maintaining-your-packages/",
          "body": " Maintaining Your Packages While publishing is, by far, the most common action you will perform when working with the packages you provide, there are other things you may need to do.  Adding a Collaborator Some packages get too big for one person. Sometimes priorities change and someone else wants to help out. You can let others help or create co-owners by adding them as a collaborator on the GitHub repository for your package. Note: Anyone that has push access to your repository will have the ability to publish new versions of the package that belongs to that repository. You can also have packages that are owned by a GitHub organization. Anyone who is a member of an organization's team which has push access to the package's repository will be able to publish new versions of the package.  Transferring Ownership  Danger:  This is a permanent change. There is no going back!   If you want to hand off support of your package to someone else, you can do that by transferring the package's repository to the new owner. Once you do that, they can publish a new version with the updated repository information in the package.json.  Unpublish Your Package If you no longer want to support your package and cannot find anyone to take it over, you can unpublish your package from https://atom.io. For example, if your package is named package-name then the command you would execute is:  apm unpublish package-name  This will remove your package from the https://atom.io package registry. Anyone who has already downloaded a copy of your package will still have it and be able to use it, but it will no longer be available for installation by others.  Unpublish a Specific Version If you mistakenly published a version of your package or perhaps you find a glaring bug or security hole, you may want to unpublish just that version of your package. For example, if your package is named package-name and the bad version of your package is v1.2.3 then the command you would execute is:  apm unpublish package-name@1.2.3  This will remove just this particular version from the https://atom.io package registry.  Rename Your Package If you need to rename your package for any reason, you can do so with one simple command – apm publish --rename changes the name field in your package's package.json, pushes a new commit and tag, and publishes your renamed package. Requests made to the previous name will be forwarded to the new name.  apm publish --rename new-package-name   Tip: Once a package name has been used, it cannot be re-used by another package even if the original package is unpublished. ",
          "excerpt": " Maintaining Your Packages While publishing is, by far, the most common action you will perform when working with the packages you provide, t…"
        },
      
    
      
        
        {
          "title": "Summary",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/summary/",
          "body": " Summary You should now have a better understanding of some of the core Atom APIs and systems.",
          "excerpt": " Summary You should now have a better understanding of some of the core Atom APIs and systems.…"
        },
      
    
      
        
        {
          "title": "Scoped Settings, Scopes and Scope Descriptors",
          "category": "",
          "category_url": "",
          "url": "/behind-atom/sections/scoped-settings-scopes-and-scope-descriptors/",
          "body": " Scoped Settings, Scopes and Scope Descriptors Atom supports language-specific settings. You can soft wrap only Markdown files, or set the tab length to 4 in Python files. Language-specific settings are a subset of something more general we call \"scoped settings\". Scoped settings allow targeting down to a specific syntax token type. For example, you could conceivably set a setting to target only Ruby comments, only code inside Markdown files, or even only JavaScript function names.  Scope Names in Syntax Tokens Each token in the editor has a collection of scope names. For example, the aforementioned JavaScript function name might have the scope names function and name. An open paren might have the scope names punctuation, parameters, begin. Scope names work just like CSS classes. In fact, in the editor, scope names are attached to a token's DOM node as CSS classes. Take this piece of JavaScript: function functionName() { console.log('Log it out'); }  In the dev tools, the first line's markup looks like this.  All the class names on the spans are scope names. Any scope name can be used to target a setting's value.  Scope Selectors Scope selectors allow you to target specific tokens just like a CSS selector targets specific nodes in the DOM. Some examples: '.source.js' # selects all javascript tokens '.source.js .function.name' # selects all javascript function names '.function.name' # selects all function names in any language  Config::set accepts a scopeSelector. If you'd like to set a setting for JavaScript function names, you can give it the JavaScript function name scopeSelector: atom.config.set('my-package.my-setting', 'special value', scopeSelector: '.source.js .function.name')   Scope Descriptors A scope descriptor is an Object that wraps an Array of Strings. The Array describes a path from the root of the syntax tree to a token including all scope names for the entire path. In our JavaScript example above, a scope descriptor for the function name token would be: ['source.js', 'meta.function.js', 'entity.name.function.js']  Config::get accepts a scopeDescriptor. You can get the value for your setting scoped to JavaScript function names via: scopeDescriptor = ['source.js', 'meta.function.js', 'entity.name.function.js'] value = atom.config.get('my-package.my-setting', scope: scopeDescriptor)  But, you do not need to generate scope descriptors by hand. There are a couple methods available to get the scope descriptor from the editor:   Editor::getRootScopeDescriptor to get the language's descriptor. For example: [\".source.js\"]   Editor::scopeDescriptorForBufferPosition to get the descriptor at a specific position in the buffer.  Cursor::getScopeDescriptor to get a cursor's descriptor based on position. eg. if the cursor were in the name of the method in our example it would return [\"source.js\", \"meta.function.js\", \"entity.name.function.js\"]   Let's revisit our example using these methods: editor = atom.workspace.getActiveTextEditor() cursor = editor.getLastCursor() valueAtCursor = atom.config.get('my-package.my-setting', scope: cursor.getScopeDescriptor()) valueForLanguage = atom.config.get('my-package.my-setting', scope: editor.getRootScopeDescriptor()) ",
          "excerpt": " Scoped Settings, Scopes and Scope Descriptors Atom supports language-specific settings. You can soft wrap only Markdown files, or set the ta…"
        },
      
    
    {}
  ]
}
